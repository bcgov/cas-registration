import { createSlice, type PayloadAction } from "@reduxjs/toolkit";
import { incrementAsync } from "./thunks";

// 🔴 Statue: set initial state of slice- counterSlice
const initialState: CounterSliceState = {
  value: 0,
  status: "idle",
};

// 🍕 Slice: create Redux Toolkit slice - counterSlice
export const counterSlice = createSlice({
  name: "counter",
  initialState,
  //`reducers` field used to update the state in a deterministic and immutable manner, lets us define and generate associated reducer functions\actions
  // Redux Toolkit simplifies the process of writing reducers by allowing you to write "mutating" logic as if you were directly modifying the state.
  // Under the hood, Immer tracks changes and produces an updated state while preserving the immutability requirement.
  reducers: {
    // a reducer takes two arguments: the current state and an action object
    increment: (state) => {
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
    // use the PayloadAction type to declare the contents of `action.payload`
    incrementByAmount: (state, action: PayloadAction<number>) => {
      state.value += action.payload;
    },
  },
  // `extraReducers` field lets the slice handle actions defined elsewhere,
  // such as, actions from other slices or functions
  // handling async actions generated by createAsyncThunk in client/redux/features/counter/thunks.ts
  extraReducers: (builder) => {
    // builder is Redux Toolkit object that allows defining these additional reducers
    builder
      .addCase(incrementAsync.pending, (state) => {
        state.status = "loading"; // 🔄 Handle a pending async action
      })
      .addCase(incrementAsync.fulfilled, (state, action) => {
        state.status = "idle"; // ✔️ Handle a successful async action
        state.value += action.payload;
      });
  },
});

// 📐 Type: define structure for type- CounterSliceState
export type CounterSliceState = {
  value: number;
  status: "idle" | "loading" | "failed";
};
