name: TruffleHog Secret Detection

on:
  workflow_call:
  workflow_dispatch:
  issues:
    types: [opened, edited, closed]
  issue_comment:
    types: [created, edited, deleted]
  pull_request:
    types: [opened, edited, synchronize, reopened, closed]
  pull_request_review_comment:
    types: [created, edited, deleted]

jobs:
  trufflehog:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
      pull-requests: write
      issues: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install GitHub CLI
        run: |
          if ! command -v gh &> /dev/null; then
            echo "Installing GitHub CLI..."
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
            sudo apt update
            sudo apt install gh -y
          fi

      - name: Run TruffleHog on repository
        id: trufflehog-repo
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          extra_args: --no-verification --json --debug
        continue-on-error: true

      - name: Prepare content for scanning
        env:
          EVENT_NAME: ${{ github.event_name }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          COMMENT_ID: ${{ github.event.comment.id }}
          COMMENT_BODY: ${{ github.event.comment.body }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          # Create temporary files for content to avoid shell injection
          TEMP_DIR=$(mktemp -d)
          CONTENT_FILE="$TEMP_DIR/content.txt"

          echo "=== Preparing Content for Scanning ==="
          echo "Event: $EVENT_NAME"

          # Get issue/PR content based on event type and write to file
          if [ "$EVENT_NAME" = "issues" ]; then
            if [ -n "$ISSUE_TITLE" ]; then
              printf '%s\n' "$ISSUE_TITLE" > "$CONTENT_FILE"
            fi
            if [ -n "$ISSUE_BODY" ]; then
              printf '%s\n' "$ISSUE_BODY" >> "$CONTENT_FILE"
            fi
          elif [ "$EVENT_NAME" = "issue_comment" ]; then
            if [ -n "$COMMENT_BODY" ]; then
              printf '%s\n' "$COMMENT_BODY" > "$CONTENT_FILE"
            fi
          elif [ "$EVENT_NAME" = "pull_request" ]; then
            if [ -n "$PR_TITLE" ]; then
              printf '%s\n' "$PR_TITLE" > "$CONTENT_FILE"
            fi
            if [ -n "$PR_BODY" ]; then
              printf '%s\n' "$PR_BODY" >> "$CONTENT_FILE"
            fi
          elif [ "$EVENT_NAME" = "pull_request_review_comment" ]; then
            if [ -n "$COMMENT_BODY" ]; then
              printf '%s\n' "$COMMENT_BODY" > "$CONTENT_FILE"
            fi
          fi

          # Check if content exists and create a temporary directory for TruffleHog
          if [ -s "$CONTENT_FILE" ]; then
            echo "Content prepared for scanning ($(wc -l < "$CONTENT_FILE") lines)"
            echo "CONTENT_DIR=$TEMP_DIR" >> $GITHUB_ENV
          else
            echo "No content to scan"
            echo "CONTENT_DIR=" >> $GITHUB_ENV
          fi
        continue-on-error: true

      - name: Run TruffleHog on content
        if: env.CONTENT_DIR != ''
        run: |
          echo "Running TruffleHog on prepared content..."

          # Install TruffleHog if not available
          if ! command -v trufflehog &> /dev/null; then
            echo "Installing TruffleHog..."
            curl -sSfL https://raw.githubusercontent.com/trufflesecurity/trufflehog/main/scripts/install.sh | sh -s -- -b /usr/local/bin
          fi

          # Run TruffleHog on the content directory
          echo "[]" > trufflehog-content-results.json
          trufflehog filesystem "$CONTENT_DIR" --no-verification --json --debug > temp-content-results.json 2>&1 || true

          # Process TruffleHog output
          if [ -s temp-content-results.json ]; then
            if jq empty temp-content-results.json 2>/dev/null; then
              # Valid JSON, use as-is
              cp temp-content-results.json trufflehog-content-results.json
            else
              # Invalid JSON, create structured result
              echo '[{"DetectorName": "TruffleHog Content Scan", "Raw": "Secrets detected but output could not be parsed", "SourceMetadata": {"Data": {"Filesystem": {"file": "content"}}}}]' > trufflehog-content-results.json
            fi
          fi
          rm -f temp-content-results.json
        env:
          CONTENT_DIR: ${{ env.CONTENT_DIR }}
        continue-on-error: true

      - name: Run fallback secret detection
        if: always() && env.CONTENT_DIR != ''
        run: |
          echo "Running fallback secret detection..."

          # Initialize fallback results
          echo "[]" > trufflehog-fallback-results.json

          if [ -f "${{ env.CONTENT_DIR }}/content.txt" ]; then
            SECRETS_DETECTED=false

            # Check for common secret patterns
            if grep -iE "(api.*key|github.*token|access.*token|secret.*key|password|pwd).*[a-zA-Z0-9+/=@:.-]{10,}" "${{ env.CONTENT_DIR }}/content.txt" > /dev/null; then
              SECRETS_DETECTED=true
            fi

            if grep -E "ghp_[a-zA-Z0-9]{36}" "${{ env.CONTENT_DIR }}/content.txt" > /dev/null; then
              SECRETS_DETECTED=true
            fi

            if grep -E "(postgresql|mysql|mongodb)://[^:]+:[^@]+@" "${{ env.CONTENT_DIR }}/content.txt" > /dev/null; then
              SECRETS_DETECTED=true
            fi

            if grep -iE "(secret|key|token|password|pwd|credential|auth).*[a-zA-Z0-9+/=@:.-]{10,}" "${{ env.CONTENT_DIR }}/content.txt" > /dev/null; then
              SECRETS_DETECTED=true
            fi

            if [ "$SECRETS_DETECTED" = "true" ]; then
              echo '[{"DetectorName": "Fallback Pattern Detection", "Raw": "Potential secrets detected by pattern matching", "SourceMetadata": {"Data": {"Filesystem": {"file": "content.txt"}}}}]' > trufflehog-fallback-results.json
            fi
          fi
        continue-on-error: true

      - name: Check for secrets and handle comment resolution
        if: always()
        run: |
          echo "Checking for secrets in TruffleHog results..."

          SECRETS_FOUND=false

          # Check repository scan results
          if [ "${{ steps.trufflehog-repo.outcome }}" = "failure" ]; then
            echo "Secrets found in repository scan"
            SECRETS_FOUND=true
          fi

          # Check content scan results
          if [ -f "trufflehog-content-results.json" ] && [ -s "trufflehog-content-results.json" ]; then
            if jq -e '. | length > 0' trufflehog-content-results.json > /dev/null 2>&1; then
              echo "Secrets found in content scan"
              SECRETS_FOUND=true
            fi
          fi

          # Check fallback results
          if [ -f "trufflehog-fallback-results.json" ] && [ -s "trufflehog-fallback-results.json" ]; then
            if jq -e '. | length > 0' trufflehog-fallback-results.json > /dev/null 2>&1; then
              echo "Secrets found in fallback detection"
              SECRETS_FOUND=true
            fi
          fi

          if [ "$SECRETS_FOUND" = "true" ]; then
            echo "SECRETS_FOUND=true" >> $GITHUB_ENV
            echo "‚ùå SECRETS DETECTED - Workflow will fail"
          else
            echo "SECRETS_FOUND=false" >> $GITHUB_ENV
            echo "‚úÖ No secrets detected - Workflow will pass"
          fi

      - name: Handle comment cleanup and CI rerun
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Check if this is a comment deletion event
            const isCommentDeleted = context.eventName === 'issue_comment' && context.payload.action === 'deleted';
            const isPRClosed = context.eventName === 'pull_request' && context.payload.action === 'closed';
            const isIssueClosed = context.eventName === 'issues' && context.payload.action === 'closed';

            console.log('Event details:', {
              eventName: context.eventName,
              action: context.payload.action,
              isCommentDeleted,
              isPRClosed,
              isIssueClosed
            });

            // If comment was deleted or PR/issue was closed, trigger a rerun
            if (isCommentDeleted || isPRClosed || isIssueClosed) {
              console.log('Comment deleted or PR/issue closed - triggering rerun...');

              // Trigger a new workflow run
              try {
                await github.rest.actions.createWorkflowDispatch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: 'trufflehog.yaml',
                  ref: context.payload.pull_request?.head?.ref || context.payload.issue?.number ? 'main' : context.ref
                });
                console.log('Workflow rerun triggered successfully');
              } catch (error) {
                console.log('Error triggering workflow rerun:', error.message);
              }
            }

            // Check if we have existing security comments
            let comments = [];
            try {
              const { data: commentsData } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue?.number || context.payload.pull_request?.number
              });
              comments = commentsData || [];
            } catch (error) {
              console.log('Error fetching comments:', error.message);
              comments = [];
            }

            const securityComments = comments.filter(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('üê∑ **TruffleHog Secret Detection Alert**')
            );

            console.log(`Found ${securityComments.length} existing security comments`);

            // If no secrets found and we have security comments, delete them
            if ('${{ env.SECRETS_FOUND }}' === 'false' && securityComments.length > 0) {
              console.log('No secrets detected - deleting existing security comments');

              for (const comment of securityComments) {
                try {
                  // Delete the security comment
                  await github.rest.issues.deleteComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: comment.id
                  });

                  console.log(`Deleted security comment ${comment.id}`);
                } catch (error) {
                  console.log(`Error deleting comment ${comment.id}:`, error.message);
                }
              }
            }

      - name: Comment on issue/PR if secrets found
        if: env.SECRETS_FOUND == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Read TruffleHog results
            let findings = [];
            try {
              // Check if repository scan found secrets
              if ('${{ steps.trufflehog-repo.outcome }}' === 'failure') {
                findings.push({
                  DetectorName: 'TruffleHog Repository Scan',
                  Raw: 'Secrets detected in repository code',
                  SourceMetadata: { Data: { Filesystem: { file: 'repository' } } }
                });
              }

              // Read content results
              if (fs.existsSync('trufflehog-content-results.json')) {
                const contentFile = fs.readFileSync('trufflehog-content-results.json', 'utf8').trim();
                if (contentFile) {
                  try {
                    const contentResults = JSON.parse(contentFile);
                    if (Array.isArray(contentResults)) {
                      findings = findings.concat(contentResults);
                    } else if (contentResults && typeof contentResults === 'object') {
                      findings.push(contentResults);
                    }
                  } catch (parseError) {
                    console.log('Error parsing content results JSON:', parseError.message);
                    if (contentFile.includes('DetectorName') || contentFile.includes('Raw')) {
                      findings.push({
                        DetectorName: 'TruffleHog Content Scan (Parse Error)',
                        Raw: 'Secrets detected but results could not be parsed',
                        SourceMetadata: { Data: { Filesystem: { file: 'content' } } }
                      });
                    }
                  }
                }
              }

              // Read fallback results
              if (fs.existsSync('trufflehog-fallback-results.json')) {
                const fallbackFile = fs.readFileSync('trufflehog-fallback-results.json', 'utf8').trim();
                if (fallbackFile) {
                  try {
                    const fallbackResults = JSON.parse(fallbackFile);
                    if (Array.isArray(fallbackResults)) {
                      findings = findings.concat(fallbackResults);
                    } else if (fallbackResults && typeof fallbackResults === 'object') {
                      findings.push(fallbackResults);
                    }
                  } catch (parseError) {
                    console.log('Error parsing fallback results JSON:', parseError.message);
                    if (fallbackFile.includes('DetectorName') || fallbackFile.includes('Raw')) {
                      findings.push({
                        DetectorName: 'TruffleHog Fallback Detection (Parse Error)',
                        Raw: 'Secrets detected but results could not be parsed',
                        SourceMetadata: { Data: { Filesystem: { file: 'fallback' } } }
                      });
                    }
                  }
                }
              }
            } catch (error) {
              console.log('Error reading TruffleHog results:', error);
            }

            let comments = [];
            try {
              const { data: commentsData } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue?.number || context.payload.pull_request?.number
              });
              comments = commentsData || [];
            } catch (error) {
              console.log('Error fetching comments:', error.message);
              comments = [];
            }

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('üê∑ **TruffleHog Secret Detection Alert**')
            );

            let findingsText = '';
            if (findings.length > 0) {
              findingsText = '\n**Detected Secrets:**\n';
              findings.slice(0, 5).forEach((finding, index) => {
                const detector = finding.DetectorName || 'Unknown';
                const file = finding.SourceMetadata?.Data?.Filesystem?.file || 'Unknown file';
                findingsText += `${index + 1}. **${detector}** in \`${file}\`\n`;
              });
              if (findings.length > 5) {
                findingsText += `\n... and ${findings.length - 5} more findings\n`;
              }
            } else {
              findingsText = '\nTruffleHog detected potential secrets but could not parse detailed results.\n';
            }

            const commentBody = `üê∑ **TruffleHog Secret Detection Alert**\n\n‚ö†Ô∏è **WARNING**: Potential secrets detected in this ${context.eventName.includes('pull_request') ? 'pull request' : 'issue'}!\n\n${findingsText}\n**Action Required**: Edit your ${context.eventName.includes('pull_request') ? 'PR' : 'issue'} to remove sensitive data before proceeding.\n\n---\n*This is an automated security check by TruffleHog.*`;

            try {
              if (botComment) {
                console.log('Bot comment already exists, updating...');
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: commentBody
                });
                console.log('Comment updated successfully');
              } else {
                console.log('Creating new bot comment...');
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue?.number || context.payload.pull_request?.number,
                  body: commentBody
                });
                console.log('Comment created successfully');
              }
            } catch (error) {
              console.log('Error creating/updating comment:', error.message);
              if (error.status === 403) {
                console.log('Permission denied - check if the workflow has proper permissions to write comments');
              }
              throw error;
            }

      - name: Handle automatic CI rerun on comment deletion
        if: always() && (github.event_name == 'issue_comment' && github.event.action == 'deleted')
        run: |
          echo "Security comment was deleted - checking if we should trigger CI rerun..."

          # Check if the deleted comment was a security alert
          if echo "${{ github.event.comment.body }}" | grep -q "üê∑ \*\*TruffleHog Secret Detection Alert\*\*"; then
            echo "Security comment was deleted - triggering CI rerun..."

            # Trigger a new workflow run using GitHub CLI or API
            if command -v gh &> /dev/null; then
              gh workflow run trufflehog.yaml --ref "${{ github.ref }}"
              echo "CI rerun triggered via GitHub CLI"
            else
              echo "GitHub CLI not available - manual rerun may be needed"
            fi
          else
            echo "Deleted comment was not a security alert - no action needed"
          fi

      - name: Fail workflow if secrets detected
        if: env.SECRETS_FOUND == 'true'
        run: |
          echo "‚ùå SECRETS DETECTED - Failing workflow"
          echo "Please remove the detected secrets and try again."
          exit 1

      - name: Upload TruffleHog results as artifact
        uses: actions/upload-artifact@v4
        with:
          name: trufflehog-results
          path: |
            trufflehog-content-results.json
            trufflehog-fallback-results.json
          if-no-files-found: ignore
