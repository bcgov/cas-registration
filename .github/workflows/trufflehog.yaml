name: TruffleHog Secret Detection

on:
  workflow_call:
  workflow_dispatch:
  issues:
    types: [opened, edited]
  issue_comment:
    types: [created, edited]
  pull_request:
    types: [opened, edited, synchronize, reopened]
  pull_request_review_comment:
    types: [created, edited]

jobs:
  trufflehog:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
      pull-requests: write
      issues: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run TruffleHog on repository
        id: trufflehog-repo
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          extra_args: --no-verification --json --debug
        continue-on-error: true

      - name: Prepare content for scanning
        env:
          EVENT_NAME: ${{ github.event_name }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          COMMENT_ID: ${{ github.event.comment.id }}
          COMMENT_BODY: ${{ github.event.comment.body }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          # Create temporary files for content to avoid shell injection
          TEMP_DIR=$(mktemp -d)
          CONTENT_FILE="$TEMP_DIR/content.txt"

          echo "=== Preparing Content for Scanning ==="
          echo "Event: $EVENT_NAME"
          echo "Debug - Environment variables:"
          echo "ISSUE_NUMBER: $ISSUE_NUMBER"
          echo "ISSUE_TITLE: $ISSUE_TITLE"
          echo "ISSUE_BODY: $ISSUE_BODY"
          echo "COMMENT_ID: $COMMENT_ID"
          echo "COMMENT_BODY: $COMMENT_BODY"
          echo "PR_NUMBER: $PR_NUMBER"
          echo "PR_TITLE: $PR_TITLE"
          echo "PR_BODY: $PR_BODY"

          # Get issue/PR content based on event type and write to file
          if [ "$EVENT_NAME" = "issues" ]; then
            echo "Preparing issue #$ISSUE_NUMBER content"
            if [ -n "$ISSUE_TITLE" ]; then
              printf '%s\n' "$ISSUE_TITLE" > "$CONTENT_FILE"
              echo "Added issue title to content file"
            fi
            if [ -n "$ISSUE_BODY" ]; then
              printf '%s\n' "$ISSUE_BODY" >> "$CONTENT_FILE"
              echo "Added issue body to content file"
            fi
          elif [ "$EVENT_NAME" = "issue_comment" ]; then
            echo "Preparing issue comment #$COMMENT_ID content"
            if [ -n "$COMMENT_BODY" ]; then
              printf '%s\n' "$COMMENT_BODY" > "$CONTENT_FILE"
              echo "Added comment body to content file"
            fi
          elif [ "$EVENT_NAME" = "pull_request" ]; then
            echo "Preparing PR #$PR_NUMBER content"
            if [ -n "$PR_TITLE" ]; then
              printf '%s\n' "$PR_TITLE" > "$CONTENT_FILE"
              echo "Added PR title to content file"
            fi
            if [ -n "$PR_BODY" ]; then
              printf '%s\n' "$PR_BODY" >> "$CONTENT_FILE"
              echo "Added PR body to content file"
            fi
          elif [ "$EVENT_NAME" = "pull_request_review_comment" ]; then
            echo "Preparing PR review comment #$COMMENT_ID content"
            if [ -n "$COMMENT_BODY" ]; then
              printf '%s\n' "$COMMENT_BODY" > "$CONTENT_FILE"
              echo "Added review comment body to content file"
            fi
          fi

          # Check if content exists and create a temporary directory for TruffleHog
          if [ -s "$CONTENT_FILE" ]; then
            echo "Content prepared for scanning ($(wc -l < "$CONTENT_FILE") lines)"
            echo "CONTENT_DIR=$TEMP_DIR" >> $GITHUB_ENV
            echo "Content preview (first 3 lines):"
            head -3 "$CONTENT_FILE"
          else
            echo "No content to scan"
            echo "CONTENT_DIR=" >> $GITHUB_ENV
          fi
        continue-on-error: true

      - name: Run TruffleHog on content
        if: env.CONTENT_DIR != ''
        run: |
          echo "Running TruffleHog on prepared content..."
          echo "Content directory: $CONTENT_DIR"
          echo "Files in content directory:"
          ls -la "$CONTENT_DIR"

          # Install TruffleHog if not available
          if ! command -v trufflehog &> /dev/null; then
            echo "Installing TruffleHog..."
            curl -sSfL https://raw.githubusercontent.com/trufflesecurity/trufflehog/main/scripts/install.sh | sh -s -- -b /usr/local/bin
          fi

          # Run TruffleHog on the content directory with proper flags
          # Use --no-verification to catch unverified secrets too, and --json for structured output
          # Also try scanning individual files to ensure detection
          echo "[]" > trufflehog-content-results.json  # Initialize with empty JSON array
          trufflehog filesystem "$CONTENT_DIR" --no-verification --json --debug > temp-content-results.json 2>&1 || true

          # Check if temp file has valid content and append to main results
          if [ -s temp-content-results.json ]; then
            # Try to parse as JSON to validate
            if jq empty temp-content-results.json 2>/dev/null; then
              # Valid JSON, append to results
              jq -s '.[0] + .[1]' trufflehog-content-results.json temp-content-results.json > merged-results.json
              mv merged-results.json trufflehog-content-results.json
            else
              echo "TruffleHog output is not valid JSON, treating as text output"
              # If not valid JSON, create a structured result
              echo "[{\"DetectorName\": \"TruffleHog Content Scan\", \"Raw\": \"$(cat temp-content-results.json | head -c 200)\", \"SourceMetadata\": {\"Data\": {\"Filesystem\": {\"file\": \"content\"}}}}]" > trufflehog-content-results.json
            fi
          fi
          rm -f temp-content-results.json

          # Also try scanning the content file directly as a fallback
          if [ -f "$CONTENT_DIR/content.txt" ]; then
            echo "Also scanning content file directly..."
            trufflehog filesystem "$CONTENT_DIR/content.txt" --no-verification --json --debug > temp-file-results.json 2>&1 || true

            if [ -s temp-file-results.json ]; then
              if jq empty temp-file-results.json 2>/dev/null; then
                # Valid JSON, append to results
                jq -s '.[0] + .[1]' trufflehog-content-results.json temp-file-results.json > merged-results.json
                mv merged-results.json trufflehog-content-results.json
              else
                echo "File scan output is not valid JSON, treating as text output"
                # If not valid JSON, create a structured result
                echo "[{\"DetectorName\": \"TruffleHog File Scan\", \"Raw\": \"$(cat temp-file-results.json | head -c 200)\", \"SourceMetadata\": {\"Data\": {\"Filesystem\": {\"file\": \"content.txt\"}}}}]" > temp-file-results.json
                jq -s '.[0] + .[1]' trufflehog-content-results.json temp-file-results.json > merged-results.json
                mv merged-results.json trufflehog-content-results.json
              fi
            fi
            rm -f temp-file-results.json
          fi
          echo "TruffleHog content scan completed"

          # Check if results file was created and show its contents
          if [ -f "trufflehog-content-results.json" ]; then
            echo "Content scan results:"
            cat trufflehog-content-results.json
            echo ""
            echo "Content scan results file size: $(wc -c < trufflehog-content-results.json) bytes"
          else
            echo "No content scan results file created"
          fi

          # Fallback: Simple pattern-based detection for obvious secrets
          echo "Running fallback pattern detection..."
          echo "[]" > trufflehog-fallback-results.json  # Initialize with empty JSON array
          if [ -f "$CONTENT_DIR/content.txt" ]; then
            echo "Content file exists, checking for secrets..."
            echo "Content file size: $(wc -c < "$CONTENT_DIR/content.txt") bytes"
            echo "Content preview:"
            head -5 "$CONTENT_DIR/content.txt"
            echo "---"
            
            # Check for common secret patterns with more comprehensive regex
            SECRETS_DETECTED=false
            FALLBACK_FINDINGS="[]"
            
            # Check for API keys, tokens, passwords
            if grep -iE "(api.*key|github.*token|access.*token|secret.*key|password|pwd).*[a-zA-Z0-9+/=@:.-]{10,}" "$CONTENT_DIR/content.txt" > /dev/null; then
              echo "Found API key/token patterns"
              SECRETS_DETECTED=true
            fi
            
            # Check for GitHub tokens specifically
            if grep -E "ghp_[a-zA-Z0-9]{36}" "$CONTENT_DIR/content.txt" > /dev/null; then
              echo "Found GitHub token pattern"
              SECRETS_DETECTED=true
            fi
            
            # Check for database URLs
            if grep -E "(postgresql|mysql|mongodb)://[^:]+:[^@]+@" "$CONTENT_DIR/content.txt" > /dev/null; then
              echo "Found database URL pattern"
              SECRETS_DETECTED=true
            fi
            
            # Check for other common secret patterns
            if grep -iE "(secret|key|token|password|pwd|credential|auth).*[a-zA-Z0-9+/=@:.-]{10,}" "$CONTENT_DIR/content.txt" > /dev/null; then
              echo "Found general secret patterns"
              SECRETS_DETECTED=true
            fi
            
            if [ "$SECRETS_DETECTED" = "true" ]; then
              echo "Fallback detection found potential secrets in content"
              # Create a more detailed JSON result for fallback detection
              echo '[{"DetectorName": "Fallback Pattern Detection", "Raw": "Potential secrets detected by pattern matching in PR/issue content", "SourceMetadata": {"Data": {"Filesystem": {"file": "content.txt"}}}}]' > trufflehog-fallback-results.json
            else
              echo "No secrets detected by fallback pattern matching"
            fi
          else
            echo "Content file does not exist for fallback detection"
          fi
        env:
          CONTENT_DIR: ${{ env.CONTENT_DIR }}
        continue-on-error: true

      - name: Run fallback secret detection
        if: always()
        run: |
          echo "Running fallback secret detection..."
          echo "Current directory contents:"
          ls -la

          # Check if we have content to scan
          if [ -n "${{ env.CONTENT_DIR }}" ] && [ -f "${{ env.CONTENT_DIR }}/content.txt" ]; then
            echo "Content directory: ${{ env.CONTENT_DIR }}"
            echo "Content file exists, running fallback detection..."
            
            # Initialize fallback results
            echo "[]" > trufflehog-fallback-results.json
            
            # Check for secrets using comprehensive patterns
            SECRETS_DETECTED=false
            
            # Check for API keys, tokens, passwords
            if grep -iE "(api.*key|github.*token|access.*token|secret.*key|password|pwd).*[a-zA-Z0-9+/=@:.-]{10,}" "${{ env.CONTENT_DIR }}/content.txt" > /dev/null; then
              echo "Found API key/token patterns"
              SECRETS_DETECTED=true
            fi
            
            # Check for GitHub tokens specifically
            if grep -E "ghp_[a-zA-Z0-9]{36}" "${{ env.CONTENT_DIR }}/content.txt" > /dev/null; then
              echo "Found GitHub token pattern"
              SECRETS_DETECTED=true
            fi
            
            # Check for database URLs
            if grep -E "(postgresql|mysql|mongodb)://[^:]+:[^@]+@" "${{ env.CONTENT_DIR }}/content.txt" > /dev/null; then
              echo "Found database URL pattern"
              SECRETS_DETECTED=true
            fi
            
            # Check for other common secret patterns
            if grep -iE "(secret|key|token|password|pwd|credential|auth).*[a-zA-Z0-9+/=@:.-]{10,}" "${{ env.CONTENT_DIR }}/content.txt" > /dev/null; then
              echo "Found general secret patterns"
              SECRETS_DETECTED=true
            fi
            
            if [ "$SECRETS_DETECTED" = "true" ]; then
              echo "Fallback detection found potential secrets in content"
              echo '[{"DetectorName": "Fallback Pattern Detection", "Raw": "Potential secrets detected by pattern matching in PR/issue content", "SourceMetadata": {"Data": {"Filesystem": {"file": "content.txt"}}}}]' > trufflehog-fallback-results.json
            else
              echo "No secrets detected by fallback pattern matching"
            fi
          else
            echo "No content directory or content file found for fallback detection"
            echo "CONTENT_DIR: ${{ env.CONTENT_DIR }}"
          fi
        continue-on-error: true

      - name: Check for secrets and comment
        if: always()
        run: |
          echo "Checking for secrets in TruffleHog results..."
          echo "Current directory contents:"
          ls -la

          # Check if any results files exist and contain findings
          SECRETS_FOUND=false

          # The TruffleHog GitHub Action outputs to stdout, so we check if it found secrets
          # by looking at the step outcome and any JSON output it might have produced
          if [ "${{ steps.trufflehog-repo.outcome }}" = "success" ] || [ "${{ steps.trufflehog-repo.outcome }}" = "failure" ]; then
            echo "Repository scan completed with outcome: ${{ steps.trufflehog-repo.outcome }}"
            # If TruffleHog found secrets, it would have failed the step, so we check for that
            if [ "${{ steps.trufflehog-repo.outcome }}" = "failure" ]; then
              echo "Secrets found in repository scan (step failed)"
              SECRETS_FOUND=true
            else
              echo "No secrets in repository scan results"
            fi
          else
            echo "Repository scan step not completed"
          fi

          if [ -f "trufflehog-content-results.json" ]; then
            echo "Content scan results file exists ($(wc -c < trufflehog-content-results.json) bytes)"
            if [ -s "trufflehog-content-results.json" ]; then
              echo "Checking content scan results..."
              echo "Content results content:"
              cat trufflehog-content-results.json
              if jq -e '. | length > 0' trufflehog-content-results.json > /dev/null 2>&1; then
                echo "Secrets found in content scan"
                SECRETS_FOUND=true
              else
                echo "No secrets in content scan results"
              fi
            else
              echo "Content scan results file is empty"
            fi
          else
            echo "Content scan results file does not exist"
          fi

          # Check fallback results
          if [ -f "trufflehog-fallback-results.json" ]; then
            echo "Fallback detection results file exists ($(wc -c < trufflehog-fallback-results.json) bytes)"
            if [ -s "trufflehog-fallback-results.json" ]; then
              echo "Checking fallback detection results..."
              echo "Fallback results content:"
              cat trufflehog-fallback-results.json
              echo "Secrets found in fallback detection"
              SECRETS_FOUND=true
            else
              echo "Fallback detection results file is empty"
            fi
          else
            echo "Fallback detection results file does not exist"
          fi

          if [ "$SECRETS_FOUND" = "true" ]; then
            echo "SECRETS_FOUND=true" >> $GITHUB_ENV
            echo "Secrets detected - will create comment"
          else
            echo "No secrets found"
            echo "SECRETS_FOUND=false" >> $GITHUB_ENV
          fi
        continue-on-error: true

      - name: Comment on issue/PR if secrets found
        if: env.SECRETS_FOUND == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Read TruffleHog results
            let findings = [];
            try {
              // Check if repository scan found secrets (step failed)
              if ('${{ steps.trufflehog-repo.outcome }}' === 'failure') {
                findings.push({
                  DetectorName: 'TruffleHog Repository Scan',
                  Raw: 'Secrets detected in repository code',
                  SourceMetadata: { Data: { Filesystem: { file: 'repository' } } }
                });
              }

              // Read content results with proper error handling
              if (fs.existsSync('trufflehog-content-results.json')) {
                const contentFile = fs.readFileSync('trufflehog-content-results.json', 'utf8').trim();
                if (contentFile) {
                  try {
                    const contentResults = JSON.parse(contentFile);
                    if (Array.isArray(contentResults)) {
                      findings = findings.concat(contentResults);
                    } else if (contentResults && typeof contentResults === 'object') {
                      findings.push(contentResults);
                    }
                  } catch (parseError) {
                    console.log('Error parsing content results JSON:', parseError.message);
                    // If JSON parsing fails, check if it contains any text that might indicate secrets
                    if (contentFile.includes('DetectorName') || contentFile.includes('Raw')) {
                      findings.push({
                        DetectorName: 'TruffleHog Content Scan (Parse Error)',
                        Raw: 'Secrets detected but results could not be parsed',
                        SourceMetadata: { Data: { Filesystem: { file: 'content' } } }
                      });
                    }
                  }
                }
              }

              // Read fallback results with proper error handling
              if (fs.existsSync('trufflehog-fallback-results.json')) {
                const fallbackFile = fs.readFileSync('trufflehog-fallback-results.json', 'utf8').trim();
                if (fallbackFile) {
                  try {
                    const fallbackResults = JSON.parse(fallbackFile);
                    if (Array.isArray(fallbackResults)) {
                      findings = findings.concat(fallbackResults);
                    } else if (fallbackResults && typeof fallbackResults === 'object') {
                      findings.push(fallbackResults);
                    }
                  } catch (parseError) {
                    console.log('Error parsing fallback results JSON:', parseError.message);
                    // If JSON parsing fails, check if it contains any text that might indicate secrets
                    if (fallbackFile.includes('DetectorName') || fallbackFile.includes('Raw')) {
                      findings.push({
                        DetectorName: 'TruffleHog Fallback Detection (Parse Error)',
                        Raw: 'Secrets detected but results could not be parsed',
                        SourceMetadata: { Data: { Filesystem: { file: 'fallback' } } }
                      });
                    }
                  }
                }
              }
            } catch (error) {
              console.log('Error reading TruffleHog results:', error);
            }

            let comments = [];
            try {
              const { data: commentsData } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue?.number || context.payload.pull_request?.number
              });
              comments = commentsData || [];
            } catch (error) {
              console.log('Error fetching comments:', error.message);
              comments = [];
            }

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('üê∑ **TruffleHog Secret Detection Alert**')
            );

            let findingsText = '';
            if (findings.length > 0) {
              findingsText = '\n**Detected Secrets:**\n';
              findings.slice(0, 5).forEach((finding, index) => {
                const detector = finding.DetectorName || 'Unknown';
                const file = finding.SourceMetadata?.Data?.Filesystem?.file || 'Unknown file';
                findingsText += `${index + 1}. **${detector}** in \`${file}\`\n`;
              });
              if (findings.length > 5) {
                findingsText += `\n... and ${findings.length - 5} more findings\n`;
              }
            } else {
              findingsText = '\nTruffleHog detected potential secrets but could not parse detailed results.\n';
            }

            const commentBody = `üê∑ **TruffleHog Secret Detection Alert**\n\n‚ö†Ô∏è **WARNING**: Potential secrets detected in this ${context.eventName.includes('pull_request') ? 'pull request' : 'issue'}!\n\n${findingsText}\n**Action Required**: Edit your ${context.eventName.includes('pull_request') ? 'PR' : 'issue'} to remove sensitive data before proceeding.\n\n---\n*This is an automated security check by TruffleHog.*`;

            try {
              if (botComment) {
                console.log('Bot comment already exists, updating...');
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: commentBody
                });
                console.log('Comment updated successfully');
              } else {
                console.log('Creating new bot comment...');
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue?.number || context.payload.pull_request?.number,
                  body: commentBody
                });
                console.log('Comment created successfully');
              }
            } catch (error) {
              console.log('Error creating/updating comment:', error.message);
              if (error.status === 403) {
                console.log('Permission denied - check if the workflow has proper permissions to write comments');
              }
              throw error; // Re-throw to fail the step if comment creation fails
            }

      - name: Upload TruffleHog results as artifact
        uses: actions/upload-artifact@v4
        with:
          name: trufflehog-results
          path: |
            trufflehog-content-results.json
            trufflehog-fallback-results.json
          if-no-files-found: ignore
