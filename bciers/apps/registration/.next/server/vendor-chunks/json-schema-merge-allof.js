/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/json-schema-merge-allof";
exports.ids = ["vendor-chunks/json-schema-merge-allof"];
exports.modules = {

/***/ "(ssr)/../../node_modules/json-schema-merge-allof/src/common.js":
/*!****************************************************************!*\
  !*** ../../node_modules/json-schema-merge-allof/src/common.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const flatten = __webpack_require__(/*! lodash/flatten */ \"(ssr)/../../node_modules/lodash/flatten.js\")\nconst flattenDeep = __webpack_require__(/*! lodash/flattenDeep */ \"(ssr)/../../node_modules/lodash/flattenDeep.js\")\nconst isPlainObject = __webpack_require__(/*! lodash/isPlainObject */ \"(ssr)/../../node_modules/lodash/isPlainObject.js\")\nconst uniq = __webpack_require__(/*! lodash/uniq */ \"(ssr)/../../node_modules/lodash/uniq.js\")\nconst uniqWith = __webpack_require__(/*! lodash/uniqWith */ \"(ssr)/../../node_modules/lodash/uniqWith.js\")\nconst without = __webpack_require__(/*! lodash/without */ \"(ssr)/../../node_modules/lodash/without.js\")\n\nfunction deleteUndefinedProps(returnObject) {\n  // cleanup empty\n  for (const prop in returnObject) {\n    if (has(returnObject, prop) && isEmptySchema(returnObject[prop])) {\n      delete returnObject[prop]\n    }\n  }\n  return returnObject\n}\n\nconst allUniqueKeys = (arr) => uniq(flattenDeep(arr.map(keys)))\nconst getValues = (schemas, key) => schemas.map(schema => schema && schema[key])\nconst has = (obj, propName) => Object.prototype.hasOwnProperty.call(obj, propName)\nconst keys = obj => {\n  if (isPlainObject(obj) || Array.isArray(obj)) {\n    return Object.keys(obj)\n  } else {\n    return []\n  }\n}\n\nconst notUndefined = (val) => val !== undefined\nconst isSchema = (val) => isPlainObject(val) || val === true || val === false\nconst isEmptySchema = (obj) => (!keys(obj).length) && obj !== false && obj !== true\nconst withoutArr = (arr, ...rest) => without.apply(null, [arr].concat(flatten(rest)))\n\nmodule.exports = {\n  allUniqueKeys,\n  deleteUndefinedProps,\n  getValues,\n  has,\n  isEmptySchema,\n  isSchema,\n  keys,\n  notUndefined,\n  uniqWith,\n  withoutArr\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLW1lcmdlLWFsbG9mL3NyYy9jb21tb24uanMiLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFPLENBQUMsa0VBQWdCO0FBQ3hDLG9CQUFvQixtQkFBTyxDQUFDLDBFQUFvQjtBQUNoRCxzQkFBc0IsbUJBQU8sQ0FBQyw4RUFBc0I7QUFDcEQsYUFBYSxtQkFBTyxDQUFDLDREQUFhO0FBQ2xDLGlCQUFpQixtQkFBTyxDQUFDLG9FQUFpQjtBQUMxQyxnQkFBZ0IsbUJBQU8sQ0FBQyxrRUFBZ0I7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtbWVyZ2UtYWxsb2Yvc3JjL2NvbW1vbi5qcz9mOTgxIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGZsYXR0ZW4gPSByZXF1aXJlKCdsb2Rhc2gvZmxhdHRlbicpXG5jb25zdCBmbGF0dGVuRGVlcCA9IHJlcXVpcmUoJ2xvZGFzaC9mbGF0dGVuRGVlcCcpXG5jb25zdCBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzUGxhaW5PYmplY3QnKVxuY29uc3QgdW5pcSA9IHJlcXVpcmUoJ2xvZGFzaC91bmlxJylcbmNvbnN0IHVuaXFXaXRoID0gcmVxdWlyZSgnbG9kYXNoL3VuaXFXaXRoJylcbmNvbnN0IHdpdGhvdXQgPSByZXF1aXJlKCdsb2Rhc2gvd2l0aG91dCcpXG5cbmZ1bmN0aW9uIGRlbGV0ZVVuZGVmaW5lZFByb3BzKHJldHVybk9iamVjdCkge1xuICAvLyBjbGVhbnVwIGVtcHR5XG4gIGZvciAoY29uc3QgcHJvcCBpbiByZXR1cm5PYmplY3QpIHtcbiAgICBpZiAoaGFzKHJldHVybk9iamVjdCwgcHJvcCkgJiYgaXNFbXB0eVNjaGVtYShyZXR1cm5PYmplY3RbcHJvcF0pKSB7XG4gICAgICBkZWxldGUgcmV0dXJuT2JqZWN0W3Byb3BdXG4gICAgfVxuICB9XG4gIHJldHVybiByZXR1cm5PYmplY3Rcbn1cblxuY29uc3QgYWxsVW5pcXVlS2V5cyA9IChhcnIpID0+IHVuaXEoZmxhdHRlbkRlZXAoYXJyLm1hcChrZXlzKSkpXG5jb25zdCBnZXRWYWx1ZXMgPSAoc2NoZW1hcywga2V5KSA9PiBzY2hlbWFzLm1hcChzY2hlbWEgPT4gc2NoZW1hICYmIHNjaGVtYVtrZXldKVxuY29uc3QgaGFzID0gKG9iaiwgcHJvcE5hbWUpID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3BOYW1lKVxuY29uc3Qga2V5cyA9IG9iaiA9PiB7XG4gIGlmIChpc1BsYWluT2JqZWN0KG9iaikgfHwgQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iailcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG5jb25zdCBub3RVbmRlZmluZWQgPSAodmFsKSA9PiB2YWwgIT09IHVuZGVmaW5lZFxuY29uc3QgaXNTY2hlbWEgPSAodmFsKSA9PiBpc1BsYWluT2JqZWN0KHZhbCkgfHwgdmFsID09PSB0cnVlIHx8IHZhbCA9PT0gZmFsc2VcbmNvbnN0IGlzRW1wdHlTY2hlbWEgPSAob2JqKSA9PiAoIWtleXMob2JqKS5sZW5ndGgpICYmIG9iaiAhPT0gZmFsc2UgJiYgb2JqICE9PSB0cnVlXG5jb25zdCB3aXRob3V0QXJyID0gKGFyciwgLi4ucmVzdCkgPT4gd2l0aG91dC5hcHBseShudWxsLCBbYXJyXS5jb25jYXQoZmxhdHRlbihyZXN0KSkpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhbGxVbmlxdWVLZXlzLFxuICBkZWxldGVVbmRlZmluZWRQcm9wcyxcbiAgZ2V0VmFsdWVzLFxuICBoYXMsXG4gIGlzRW1wdHlTY2hlbWEsXG4gIGlzU2NoZW1hLFxuICBrZXlzLFxuICBub3RVbmRlZmluZWQsXG4gIHVuaXFXaXRoLFxuICB3aXRob3V0QXJyXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/json-schema-merge-allof/src/common.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/json-schema-merge-allof/src/complex-resolvers/items.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/json-schema-merge-allof/src/complex-resolvers/items.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst compare = __webpack_require__(/*! json-schema-compare */ \"(ssr)/../../node_modules/json-schema-compare/src/index.js\")\nconst forEach = __webpack_require__(/*! lodash/forEach */ \"(ssr)/../../node_modules/lodash/forEach.js\")\nconst {\n  allUniqueKeys,\n  deleteUndefinedProps,\n  has,\n  isSchema,\n  notUndefined,\n  uniqWith\n} = __webpack_require__(/*! ../common */ \"(ssr)/../../node_modules/json-schema-merge-allof/src/common.js\")\n\nfunction removeFalseSchemasFromArray(target) {\n  forEach(target, function(schema, index) {\n    if (schema === false) {\n      target.splice(index, 1)\n    }\n  })\n}\n\nfunction getItemSchemas(subSchemas, key) {\n  return subSchemas.map(function(sub) {\n    if (!sub) {\n      return undefined\n    }\n\n    if (Array.isArray(sub.items)) {\n      const schemaAtPos = sub.items[key]\n      if (isSchema(schemaAtPos)) {\n        return schemaAtPos\n      } else if (has(sub, 'additionalItems')) {\n        return sub.additionalItems\n      }\n    } else {\n      return sub.items\n    }\n\n    return undefined\n  })\n}\n\nfunction getAdditionalSchemas(subSchemas) {\n  return subSchemas.map(function(sub) {\n    if (!sub) {\n      return undefined\n    }\n    if (Array.isArray(sub.items)) {\n      return sub.additionalItems\n    }\n    return sub.items\n  })\n}\n\n// Provide source when array\nfunction mergeItems(group, mergeSchemas, items) {\n  const allKeys = allUniqueKeys(items)\n  return allKeys.reduce(function(all, key) {\n    const schemas = getItemSchemas(group, key)\n    const compacted = uniqWith(schemas.filter(notUndefined), compare)\n    all[key] = mergeSchemas(compacted, key)\n    return all\n  }, [])\n}\n\nmodule.exports = {\n  keywords: ['items', 'additionalItems'],\n  resolver(values, parents, mergers) {\n    // const createSubMerger = groupKey => (schemas, key) => mergeSchemas(schemas, parents.concat(groupKey, key))\n    const items = values.map(s => s.items)\n    const itemsCompacted = items.filter(notUndefined)\n    const returnObject = {}\n\n    // if all items keyword values are schemas, we can merge them as simple schemas\n    // if not we need to merge them as mixed\n    if (itemsCompacted.every(isSchema)) {\n      returnObject.items = mergers.items(items)\n    } else {\n      returnObject.items = mergeItems(values, mergers.items, items)\n    }\n\n    let schemasAtLastPos\n    if (itemsCompacted.every(Array.isArray)) {\n      schemasAtLastPos = values.map(s => s.additionalItems)\n    } else if (itemsCompacted.some(Array.isArray)) {\n      schemasAtLastPos = getAdditionalSchemas(values)\n    }\n\n    if (schemasAtLastPos) {\n      returnObject.additionalItems = mergers.additionalItems(schemasAtLastPos)\n    }\n\n    if (returnObject.additionalItems === false && Array.isArray(returnObject.items)) {\n      removeFalseSchemasFromArray(returnObject.items)\n    }\n\n    return deleteUndefinedProps(returnObject)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLW1lcmdlLWFsbG9mL3NyYy9jb21wbGV4LXJlc29sdmVycy9pdGVtcy5qcyIsIm1hcHBpbmdzIjoiO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsc0ZBQXFCO0FBQzdDLGdCQUFnQixtQkFBTyxDQUFDLGtFQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLGlGQUFXOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLW1lcmdlLWFsbG9mL3NyYy9jb21wbGV4LXJlc29sdmVycy9pdGVtcy5qcz8xODdhIl0sInNvdXJjZXNDb250ZW50IjpbIlxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJ2pzb24tc2NoZW1hLWNvbXBhcmUnKVxuY29uc3QgZm9yRWFjaCA9IHJlcXVpcmUoJ2xvZGFzaC9mb3JFYWNoJylcbmNvbnN0IHtcbiAgYWxsVW5pcXVlS2V5cyxcbiAgZGVsZXRlVW5kZWZpbmVkUHJvcHMsXG4gIGhhcyxcbiAgaXNTY2hlbWEsXG4gIG5vdFVuZGVmaW5lZCxcbiAgdW5pcVdpdGhcbn0gPSByZXF1aXJlKCcuLi9jb21tb24nKVxuXG5mdW5jdGlvbiByZW1vdmVGYWxzZVNjaGVtYXNGcm9tQXJyYXkodGFyZ2V0KSB7XG4gIGZvckVhY2godGFyZ2V0LCBmdW5jdGlvbihzY2hlbWEsIGluZGV4KSB7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgIHRhcmdldC5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBnZXRJdGVtU2NoZW1hcyhzdWJTY2hlbWFzLCBrZXkpIHtcbiAgcmV0dXJuIHN1YlNjaGVtYXMubWFwKGZ1bmN0aW9uKHN1Yikge1xuICAgIGlmICghc3ViKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3ViLml0ZW1zKSkge1xuICAgICAgY29uc3Qgc2NoZW1hQXRQb3MgPSBzdWIuaXRlbXNba2V5XVxuICAgICAgaWYgKGlzU2NoZW1hKHNjaGVtYUF0UG9zKSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hQXRQb3NcbiAgICAgIH0gZWxzZSBpZiAoaGFzKHN1YiwgJ2FkZGl0aW9uYWxJdGVtcycpKSB7XG4gICAgICAgIHJldHVybiBzdWIuYWRkaXRpb25hbEl0ZW1zXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdWIuaXRlbXNcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGdldEFkZGl0aW9uYWxTY2hlbWFzKHN1YlNjaGVtYXMpIHtcbiAgcmV0dXJuIHN1YlNjaGVtYXMubWFwKGZ1bmN0aW9uKHN1Yikge1xuICAgIGlmICghc3ViKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHN1Yi5pdGVtcykpIHtcbiAgICAgIHJldHVybiBzdWIuYWRkaXRpb25hbEl0ZW1zXG4gICAgfVxuICAgIHJldHVybiBzdWIuaXRlbXNcbiAgfSlcbn1cblxuLy8gUHJvdmlkZSBzb3VyY2Ugd2hlbiBhcnJheVxuZnVuY3Rpb24gbWVyZ2VJdGVtcyhncm91cCwgbWVyZ2VTY2hlbWFzLCBpdGVtcykge1xuICBjb25zdCBhbGxLZXlzID0gYWxsVW5pcXVlS2V5cyhpdGVtcylcbiAgcmV0dXJuIGFsbEtleXMucmVkdWNlKGZ1bmN0aW9uKGFsbCwga2V5KSB7XG4gICAgY29uc3Qgc2NoZW1hcyA9IGdldEl0ZW1TY2hlbWFzKGdyb3VwLCBrZXkpXG4gICAgY29uc3QgY29tcGFjdGVkID0gdW5pcVdpdGgoc2NoZW1hcy5maWx0ZXIobm90VW5kZWZpbmVkKSwgY29tcGFyZSlcbiAgICBhbGxba2V5XSA9IG1lcmdlU2NoZW1hcyhjb21wYWN0ZWQsIGtleSlcbiAgICByZXR1cm4gYWxsXG4gIH0sIFtdKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAga2V5d29yZHM6IFsnaXRlbXMnLCAnYWRkaXRpb25hbEl0ZW1zJ10sXG4gIHJlc29sdmVyKHZhbHVlcywgcGFyZW50cywgbWVyZ2Vycykge1xuICAgIC8vIGNvbnN0IGNyZWF0ZVN1Yk1lcmdlciA9IGdyb3VwS2V5ID0+IChzY2hlbWFzLCBrZXkpID0+IG1lcmdlU2NoZW1hcyhzY2hlbWFzLCBwYXJlbnRzLmNvbmNhdChncm91cEtleSwga2V5KSlcbiAgICBjb25zdCBpdGVtcyA9IHZhbHVlcy5tYXAocyA9PiBzLml0ZW1zKVxuICAgIGNvbnN0IGl0ZW1zQ29tcGFjdGVkID0gaXRlbXMuZmlsdGVyKG5vdFVuZGVmaW5lZClcbiAgICBjb25zdCByZXR1cm5PYmplY3QgPSB7fVxuXG4gICAgLy8gaWYgYWxsIGl0ZW1zIGtleXdvcmQgdmFsdWVzIGFyZSBzY2hlbWFzLCB3ZSBjYW4gbWVyZ2UgdGhlbSBhcyBzaW1wbGUgc2NoZW1hc1xuICAgIC8vIGlmIG5vdCB3ZSBuZWVkIHRvIG1lcmdlIHRoZW0gYXMgbWl4ZWRcbiAgICBpZiAoaXRlbXNDb21wYWN0ZWQuZXZlcnkoaXNTY2hlbWEpKSB7XG4gICAgICByZXR1cm5PYmplY3QuaXRlbXMgPSBtZXJnZXJzLml0ZW1zKGl0ZW1zKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5PYmplY3QuaXRlbXMgPSBtZXJnZUl0ZW1zKHZhbHVlcywgbWVyZ2Vycy5pdGVtcywgaXRlbXMpXG4gICAgfVxuXG4gICAgbGV0IHNjaGVtYXNBdExhc3RQb3NcbiAgICBpZiAoaXRlbXNDb21wYWN0ZWQuZXZlcnkoQXJyYXkuaXNBcnJheSkpIHtcbiAgICAgIHNjaGVtYXNBdExhc3RQb3MgPSB2YWx1ZXMubWFwKHMgPT4gcy5hZGRpdGlvbmFsSXRlbXMpXG4gICAgfSBlbHNlIGlmIChpdGVtc0NvbXBhY3RlZC5zb21lKEFycmF5LmlzQXJyYXkpKSB7XG4gICAgICBzY2hlbWFzQXRMYXN0UG9zID0gZ2V0QWRkaXRpb25hbFNjaGVtYXModmFsdWVzKVxuICAgIH1cblxuICAgIGlmIChzY2hlbWFzQXRMYXN0UG9zKSB7XG4gICAgICByZXR1cm5PYmplY3QuYWRkaXRpb25hbEl0ZW1zID0gbWVyZ2Vycy5hZGRpdGlvbmFsSXRlbXMoc2NoZW1hc0F0TGFzdFBvcylcbiAgICB9XG5cbiAgICBpZiAocmV0dXJuT2JqZWN0LmFkZGl0aW9uYWxJdGVtcyA9PT0gZmFsc2UgJiYgQXJyYXkuaXNBcnJheShyZXR1cm5PYmplY3QuaXRlbXMpKSB7XG4gICAgICByZW1vdmVGYWxzZVNjaGVtYXNGcm9tQXJyYXkocmV0dXJuT2JqZWN0Lml0ZW1zKVxuICAgIH1cblxuICAgIHJldHVybiBkZWxldGVVbmRlZmluZWRQcm9wcyhyZXR1cm5PYmplY3QpXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/json-schema-merge-allof/src/complex-resolvers/items.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/json-schema-merge-allof/src/complex-resolvers/properties.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/json-schema-merge-allof/src/complex-resolvers/properties.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst compare = __webpack_require__(/*! json-schema-compare */ \"(ssr)/../../node_modules/json-schema-compare/src/index.js\")\nconst forEach = __webpack_require__(/*! lodash/forEach */ \"(ssr)/../../node_modules/lodash/forEach.js\")\nconst {\n  allUniqueKeys,\n  deleteUndefinedProps,\n  getValues,\n  keys,\n  notUndefined,\n  uniqWith,\n  withoutArr\n} = __webpack_require__(/*! ../common */ \"(ssr)/../../node_modules/json-schema-merge-allof/src/common.js\")\n\nfunction removeFalseSchemas(target) {\n  forEach(target, function(schema, prop) {\n    if (schema === false) {\n      delete target[prop]\n    }\n  })\n}\n\nfunction mergeSchemaGroup(group, mergeSchemas) {\n  const allKeys = allUniqueKeys(group)\n  return allKeys.reduce(function(all, key) {\n    const schemas = getValues(group, key)\n    const compacted = uniqWith(schemas.filter(notUndefined), compare)\n    all[key] = mergeSchemas(compacted, key)\n    return all\n  }, {})\n}\n\nmodule.exports = {\n  keywords: ['properties', 'patternProperties', 'additionalProperties'],\n  resolver(values, parents, mergers, options) {\n    // first get rid of all non permitted properties\n    if (!options.ignoreAdditionalProperties) {\n      values.forEach(function(subSchema) {\n        const otherSubSchemas = values.filter(s => s !== subSchema)\n        const ownKeys = keys(subSchema.properties)\n        const ownPatternKeys = keys(subSchema.patternProperties)\n        const ownPatterns = ownPatternKeys.map(k => new RegExp(k))\n        otherSubSchemas.forEach(function(other) {\n          const allOtherKeys = keys(other.properties)\n          const keysMatchingPattern = allOtherKeys.filter(k => ownPatterns.some(pk => pk.test(k)))\n          const additionalKeys = withoutArr(allOtherKeys, ownKeys, keysMatchingPattern)\n          additionalKeys.forEach(function(key) {\n            other.properties[key] = mergers.properties([\n              other.properties[key], subSchema.additionalProperties\n            ], key)\n          })\n        })\n      })\n\n      // remove disallowed patternProperties\n      values.forEach(function(subSchema) {\n        const otherSubSchemas = values.filter(s => s !== subSchema)\n        const ownPatternKeys = keys(subSchema.patternProperties)\n        if (subSchema.additionalProperties === false) {\n          otherSubSchemas.forEach(function(other) {\n            const allOtherPatterns = keys(other.patternProperties)\n            const additionalPatternKeys = withoutArr(allOtherPatterns, ownPatternKeys)\n            additionalPatternKeys.forEach(key => delete other.patternProperties[key])\n          })\n        }\n      })\n    }\n\n    const returnObject = {\n      additionalProperties: mergers.additionalProperties(values.map(s => s.additionalProperties)),\n      patternProperties: mergeSchemaGroup(values.map(s => s.patternProperties), mergers.patternProperties),\n      properties: mergeSchemaGroup(values.map(s => s.properties), mergers.properties)\n    }\n\n    if (returnObject.additionalProperties === false) {\n      removeFalseSchemas(returnObject.properties)\n    }\n\n    return deleteUndefinedProps(returnObject)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLW1lcmdlLWFsbG9mL3NyYy9jb21wbGV4LXJlc29sdmVycy9wcm9wZXJ0aWVzLmpzIiwibWFwcGluZ3MiOiI7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDN0MsZ0JBQWdCLG1CQUFPLENBQUMsa0VBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxpRkFBVzs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1tZXJnZS1hbGxvZi9zcmMvY29tcGxleC1yZXNvbHZlcnMvcHJvcGVydGllcy5qcz8xMDZkIl0sInNvdXJjZXNDb250ZW50IjpbIlxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJ2pzb24tc2NoZW1hLWNvbXBhcmUnKVxuY29uc3QgZm9yRWFjaCA9IHJlcXVpcmUoJ2xvZGFzaC9mb3JFYWNoJylcbmNvbnN0IHtcbiAgYWxsVW5pcXVlS2V5cyxcbiAgZGVsZXRlVW5kZWZpbmVkUHJvcHMsXG4gIGdldFZhbHVlcyxcbiAga2V5cyxcbiAgbm90VW5kZWZpbmVkLFxuICB1bmlxV2l0aCxcbiAgd2l0aG91dEFyclxufSA9IHJlcXVpcmUoJy4uL2NvbW1vbicpXG5cbmZ1bmN0aW9uIHJlbW92ZUZhbHNlU2NoZW1hcyh0YXJnZXQpIHtcbiAgZm9yRWFjaCh0YXJnZXQsIGZ1bmN0aW9uKHNjaGVtYSwgcHJvcCkge1xuICAgIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBtZXJnZVNjaGVtYUdyb3VwKGdyb3VwLCBtZXJnZVNjaGVtYXMpIHtcbiAgY29uc3QgYWxsS2V5cyA9IGFsbFVuaXF1ZUtleXMoZ3JvdXApXG4gIHJldHVybiBhbGxLZXlzLnJlZHVjZShmdW5jdGlvbihhbGwsIGtleSkge1xuICAgIGNvbnN0IHNjaGVtYXMgPSBnZXRWYWx1ZXMoZ3JvdXAsIGtleSlcbiAgICBjb25zdCBjb21wYWN0ZWQgPSB1bmlxV2l0aChzY2hlbWFzLmZpbHRlcihub3RVbmRlZmluZWQpLCBjb21wYXJlKVxuICAgIGFsbFtrZXldID0gbWVyZ2VTY2hlbWFzKGNvbXBhY3RlZCwga2V5KVxuICAgIHJldHVybiBhbGxcbiAgfSwge30pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrZXl3b3JkczogWydwcm9wZXJ0aWVzJywgJ3BhdHRlcm5Qcm9wZXJ0aWVzJywgJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJ10sXG4gIHJlc29sdmVyKHZhbHVlcywgcGFyZW50cywgbWVyZ2Vycywgb3B0aW9ucykge1xuICAgIC8vIGZpcnN0IGdldCByaWQgb2YgYWxsIG5vbiBwZXJtaXR0ZWQgcHJvcGVydGllc1xuICAgIGlmICghb3B0aW9ucy5pZ25vcmVBZGRpdGlvbmFsUHJvcGVydGllcykge1xuICAgICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24oc3ViU2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IG90aGVyU3ViU2NoZW1hcyA9IHZhbHVlcy5maWx0ZXIocyA9PiBzICE9PSBzdWJTY2hlbWEpXG4gICAgICAgIGNvbnN0IG93bktleXMgPSBrZXlzKHN1YlNjaGVtYS5wcm9wZXJ0aWVzKVxuICAgICAgICBjb25zdCBvd25QYXR0ZXJuS2V5cyA9IGtleXMoc3ViU2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKVxuICAgICAgICBjb25zdCBvd25QYXR0ZXJucyA9IG93blBhdHRlcm5LZXlzLm1hcChrID0+IG5ldyBSZWdFeHAoaykpXG4gICAgICAgIG90aGVyU3ViU2NoZW1hcy5mb3JFYWNoKGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICAgICAgY29uc3QgYWxsT3RoZXJLZXlzID0ga2V5cyhvdGhlci5wcm9wZXJ0aWVzKVxuICAgICAgICAgIGNvbnN0IGtleXNNYXRjaGluZ1BhdHRlcm4gPSBhbGxPdGhlcktleXMuZmlsdGVyKGsgPT4gb3duUGF0dGVybnMuc29tZShwayA9PiBway50ZXN0KGspKSlcbiAgICAgICAgICBjb25zdCBhZGRpdGlvbmFsS2V5cyA9IHdpdGhvdXRBcnIoYWxsT3RoZXJLZXlzLCBvd25LZXlzLCBrZXlzTWF0Y2hpbmdQYXR0ZXJuKVxuICAgICAgICAgIGFkZGl0aW9uYWxLZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBvdGhlci5wcm9wZXJ0aWVzW2tleV0gPSBtZXJnZXJzLnByb3BlcnRpZXMoW1xuICAgICAgICAgICAgICBvdGhlci5wcm9wZXJ0aWVzW2tleV0sIHN1YlNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllc1xuICAgICAgICAgICAgXSwga2V5KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuXG4gICAgICAvLyByZW1vdmUgZGlzYWxsb3dlZCBwYXR0ZXJuUHJvcGVydGllc1xuICAgICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24oc3ViU2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IG90aGVyU3ViU2NoZW1hcyA9IHZhbHVlcy5maWx0ZXIocyA9PiBzICE9PSBzdWJTY2hlbWEpXG4gICAgICAgIGNvbnN0IG93blBhdHRlcm5LZXlzID0ga2V5cyhzdWJTY2hlbWEucGF0dGVyblByb3BlcnRpZXMpXG4gICAgICAgIGlmIChzdWJTY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgb3RoZXJTdWJTY2hlbWFzLmZvckVhY2goZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGFsbE90aGVyUGF0dGVybnMgPSBrZXlzKG90aGVyLnBhdHRlcm5Qcm9wZXJ0aWVzKVxuICAgICAgICAgICAgY29uc3QgYWRkaXRpb25hbFBhdHRlcm5LZXlzID0gd2l0aG91dEFycihhbGxPdGhlclBhdHRlcm5zLCBvd25QYXR0ZXJuS2V5cylcbiAgICAgICAgICAgIGFkZGl0aW9uYWxQYXR0ZXJuS2V5cy5mb3JFYWNoKGtleSA9PiBkZWxldGUgb3RoZXIucGF0dGVyblByb3BlcnRpZXNba2V5XSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IHJldHVybk9iamVjdCA9IHtcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBtZXJnZXJzLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKHZhbHVlcy5tYXAocyA9PiBzLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSksXG4gICAgICBwYXR0ZXJuUHJvcGVydGllczogbWVyZ2VTY2hlbWFHcm91cCh2YWx1ZXMubWFwKHMgPT4gcy5wYXR0ZXJuUHJvcGVydGllcyksIG1lcmdlcnMucGF0dGVyblByb3BlcnRpZXMpLFxuICAgICAgcHJvcGVydGllczogbWVyZ2VTY2hlbWFHcm91cCh2YWx1ZXMubWFwKHMgPT4gcy5wcm9wZXJ0aWVzKSwgbWVyZ2Vycy5wcm9wZXJ0aWVzKVxuICAgIH1cblxuICAgIGlmIChyZXR1cm5PYmplY3QuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IGZhbHNlKSB7XG4gICAgICByZW1vdmVGYWxzZVNjaGVtYXMocmV0dXJuT2JqZWN0LnByb3BlcnRpZXMpXG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbGV0ZVVuZGVmaW5lZFByb3BzKHJldHVybk9iamVjdClcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/json-schema-merge-allof/src/complex-resolvers/properties.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/json-schema-merge-allof/src/index.js":
/*!***************************************************************!*\
  !*** ../../node_modules/json-schema-merge-allof/src/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const cloneDeep = __webpack_require__(/*! lodash/cloneDeep */ \"(ssr)/../../node_modules/lodash/cloneDeep.js\")\nconst compare = __webpack_require__(/*! json-schema-compare */ \"(ssr)/../../node_modules/json-schema-compare/src/index.js\")\nconst computeLcm = __webpack_require__(/*! compute-lcm */ \"(ssr)/../../node_modules/compute-lcm/lib/index.js\")\nconst defaultsDeep = __webpack_require__(/*! lodash/defaultsDeep */ \"(ssr)/../../node_modules/lodash/defaultsDeep.js\")\nconst flatten = __webpack_require__(/*! lodash/flatten */ \"(ssr)/../../node_modules/lodash/flatten.js\")\nconst flattenDeep = __webpack_require__(/*! lodash/flattenDeep */ \"(ssr)/../../node_modules/lodash/flattenDeep.js\")\nconst intersection = __webpack_require__(/*! lodash/intersection */ \"(ssr)/../../node_modules/lodash/intersection.js\")\nconst intersectionWith = __webpack_require__(/*! lodash/intersectionWith */ \"(ssr)/../../node_modules/lodash/intersectionWith.js\")\nconst isEqual = __webpack_require__(/*! lodash/isEqual */ \"(ssr)/../../node_modules/lodash/isEqual.js\")\nconst isPlainObject = __webpack_require__(/*! lodash/isPlainObject */ \"(ssr)/../../node_modules/lodash/isPlainObject.js\")\nconst pullAll = __webpack_require__(/*! lodash/pullAll */ \"(ssr)/../../node_modules/lodash/pullAll.js\")\nconst sortBy = __webpack_require__(/*! lodash/sortBy */ \"(ssr)/../../node_modules/lodash/sortBy.js\")\nconst uniq = __webpack_require__(/*! lodash/uniq */ \"(ssr)/../../node_modules/lodash/uniq.js\")\nconst uniqWith = __webpack_require__(/*! lodash/uniqWith */ \"(ssr)/../../node_modules/lodash/uniqWith.js\")\n\nconst propertiesResolver = __webpack_require__(/*! ./complex-resolvers/properties */ \"(ssr)/../../node_modules/json-schema-merge-allof/src/complex-resolvers/properties.js\")\nconst itemsResolver = __webpack_require__(/*! ./complex-resolvers/items */ \"(ssr)/../../node_modules/json-schema-merge-allof/src/complex-resolvers/items.js\")\n\nconst contains = (arr, val) => arr.indexOf(val) !== -1\nconst isSchema = (val) => isPlainObject(val) || val === true || val === false\nconst isFalse = (val) => val === false\nconst isTrue = (val) => val === true\nconst schemaResolver = (compacted, key, mergeSchemas) => mergeSchemas(compacted)\nconst stringArray = (values) => sortBy(uniq(flattenDeep(values)))\nconst notUndefined = (val) => val !== undefined\nconst allUniqueKeys = (arr) => uniq(flattenDeep(arr.map(keys)))\n\n// resolvers\nconst first = compacted => compacted[0]\nconst required = compacted => stringArray(compacted)\nconst maximumValue = compacted => Math.max.apply(Math, compacted)\nconst minimumValue = compacted => Math.min.apply(Math, compacted)\nconst uniqueItems = compacted => compacted.some(isTrue)\nconst examples = compacted => uniqWith(flatten(compacted), isEqual)\n\nfunction compareProp(key) {\n  return function(a, b) {\n    return compare({\n      [key]: a\n    }, { [key]: b })\n  }\n}\n\nfunction getAllOf(schema) {\n  let { allOf = [], ...copy } = schema\n  copy = isPlainObject(schema) ? copy : schema // if schema is boolean\n  return [copy, ...allOf.map(getAllOf)]\n}\n\nfunction getValues(schemas, key) {\n  return schemas.map(schema => schema && schema[key])\n}\n\nfunction tryMergeSchemaGroups(schemaGroups, mergeSchemas) {\n  return schemaGroups.map(function(schemas, index) {\n    try {\n      return mergeSchemas(schemas, index)\n    } catch (e) {\n      return undefined\n    }\n  }).filter(notUndefined)\n}\n\nfunction keys(obj) {\n  if (isPlainObject(obj) || Array.isArray(obj)) {\n    return Object.keys(obj)\n  } else {\n    return []\n  }\n}\n\nfunction getAnyOfCombinations(arrOfArrays, combinations) {\n  combinations = combinations || []\n  if (!arrOfArrays.length) {\n    return combinations\n  }\n\n  const values = arrOfArrays.slice(0).shift()\n  const rest = arrOfArrays.slice(1)\n  if (combinations.length) {\n    return getAnyOfCombinations(rest, flatten(combinations.map(combination => values.map(item => ([item].concat(combination))))))\n  }\n  return getAnyOfCombinations(rest, values.map(item => (item)))\n}\n\nfunction throwIncompatible(values, paths) {\n  let asJSON\n  try {\n    asJSON = values.map(function(val) {\n      return JSON.stringify(val, null, 2)\n    }).join('\\n')\n  } catch (variable) {\n    asJSON = values.join(', ')\n  }\n  throw new Error('Could not resolve values for path:\"' + paths.join('.') + '\". They are probably incompatible. Values: \\n' + asJSON)\n}\n\nfunction callGroupResolver(complexKeywords, resolverName, schemas, mergeSchemas, options, parents) {\n  if (complexKeywords.length) {\n    const resolverConfig = options.complexResolvers[resolverName]\n    if (!resolverConfig || !resolverConfig.resolver) {\n      throw new Error('No resolver found for ' + resolverName)\n    }\n\n    // extract all keywords from all the schemas that have one or more\n    // then remove all undefined ones and not unique\n    const extractedKeywordsOnly = schemas.map(schema => complexKeywords.reduce((all, key) => {\n      if (schema[key] !== undefined) all[key] = schema[key]\n      return all\n    }, {}))\n    const unique = uniqWith(extractedKeywordsOnly, compare)\n\n    // create mergers that automatically add the path of the keyword for use in the complex resolver\n    const mergers = resolverConfig.keywords.reduce((all, key) => ({\n      ...all,\n      [key]: (schemas, extraKey = []) => mergeSchemas(schemas, null, parents.concat(key, extraKey))\n    }), {})\n\n    const result = resolverConfig.resolver(unique, parents.concat(resolverName), mergers, options)\n\n    if (!isPlainObject(result)) {\n      throwIncompatible(unique, parents.concat(resolverName))\n    }\n\n    return result\n  }\n}\n\nfunction createRequiredMetaArray(arr) {\n  return { required: arr }\n}\n\nconst schemaGroupProps = ['properties', 'patternProperties', 'definitions', 'dependencies']\nconst schemaArrays = ['anyOf', 'oneOf']\nconst schemaProps = [\n  'additionalProperties',\n  'additionalItems',\n  'contains',\n  'propertyNames',\n  'not',\n  'items'\n]\n\nconst defaultResolvers = {\n  type(compacted) {\n    if (compacted.some(Array.isArray)) {\n      const normalized = compacted.map(function(val) {\n        return Array.isArray(val)\n          ? val\n          : [val]\n      })\n      const common = intersection.apply(null, normalized)\n\n      if (common.length === 1) {\n        return common[0]\n      } else if (common.length > 1) {\n        return uniq(common)\n      }\n    }\n  },\n  dependencies(compacted, paths, mergeSchemas) {\n    const allChildren = allUniqueKeys(compacted)\n\n    return allChildren.reduce(function(all, childKey) {\n      const childSchemas = getValues(compacted, childKey)\n      let innerCompacted = uniqWith(childSchemas.filter(notUndefined), isEqual)\n\n      // to support dependencies\n      const innerArrays = innerCompacted.filter(Array.isArray)\n\n      if (innerArrays.length) {\n        if (innerArrays.length === innerCompacted.length) {\n          all[childKey] = stringArray(innerCompacted)\n        } else {\n          const innerSchemas = innerCompacted.filter(isSchema)\n          const arrayMetaScheams = innerArrays.map(createRequiredMetaArray)\n          all[childKey] = mergeSchemas(innerSchemas.concat(arrayMetaScheams), childKey)\n        }\n        return all\n      }\n\n      innerCompacted = uniqWith(innerCompacted, compare)\n\n      all[childKey] = mergeSchemas(innerCompacted, childKey)\n      return all\n    }, {})\n  },\n  oneOf(compacted, paths, mergeSchemas) {\n    const combinations = getAnyOfCombinations(cloneDeep(compacted))\n    const result = tryMergeSchemaGroups(combinations, mergeSchemas)\n    const unique = uniqWith(result, compare)\n\n    if (unique.length) {\n      return unique\n    }\n  },\n  not(compacted) {\n    return { anyOf: compacted }\n  },\n  pattern(compacted) {\n    return compacted.map(r => '(?=' + r + ')').join('')\n  },\n  multipleOf(compacted) {\n    let integers = compacted.slice(0)\n    let factor = 1\n    while (integers.some(n => !Number.isInteger(n))) {\n      integers = integers.map(n => n * 10)\n      factor = factor * 10\n    }\n    return computeLcm(integers) / factor\n  },\n  enum(compacted) {\n    const enums = intersectionWith.apply(null, compacted.concat(isEqual))\n    if (enums.length) {\n      return sortBy(enums)\n    }\n  }\n}\n\ndefaultResolvers.$id = first\ndefaultResolvers.$ref = first\ndefaultResolvers.$schema = first\ndefaultResolvers.additionalItems = schemaResolver\ndefaultResolvers.additionalProperties = schemaResolver\ndefaultResolvers.anyOf = defaultResolvers.oneOf\ndefaultResolvers.contains = schemaResolver\ndefaultResolvers.default = first\ndefaultResolvers.definitions = defaultResolvers.dependencies\ndefaultResolvers.description = first\ndefaultResolvers.examples = examples\ndefaultResolvers.exclusiveMaximum = minimumValue\ndefaultResolvers.exclusiveMinimum = maximumValue\ndefaultResolvers.items = itemsResolver\ndefaultResolvers.maximum = minimumValue\ndefaultResolvers.maxItems = minimumValue\ndefaultResolvers.maxLength = minimumValue\ndefaultResolvers.maxProperties = minimumValue\ndefaultResolvers.minimum = maximumValue\ndefaultResolvers.minItems = maximumValue\ndefaultResolvers.minLength = maximumValue\ndefaultResolvers.minProperties = maximumValue\ndefaultResolvers.properties = propertiesResolver\ndefaultResolvers.propertyNames = schemaResolver\ndefaultResolvers.required = required\ndefaultResolvers.title = first\ndefaultResolvers.uniqueItems = uniqueItems\n\nconst defaultComplexResolvers = {\n  properties: propertiesResolver,\n  items: itemsResolver\n}\n\nfunction merger(rootSchema, options, totalSchemas) {\n  totalSchemas = totalSchemas || []\n  options = defaultsDeep(options, {\n    ignoreAdditionalProperties: false,\n    resolvers: defaultResolvers,\n    complexResolvers: defaultComplexResolvers,\n    deep: true\n  })\n\n  const complexResolvers = Object.entries(options.complexResolvers)\n\n  function mergeSchemas(schemas, base, parents) {\n    schemas = cloneDeep(schemas.filter(notUndefined))\n    parents = parents || []\n    const merged = isPlainObject(base)\n      ? base\n      : {}\n\n    // return undefined, an empty schema\n    if (!schemas.length) {\n      return\n    }\n\n    if (schemas.some(isFalse)) {\n      return false\n    }\n\n    if (schemas.every(isTrue)) {\n      return true\n    }\n\n    // there are no false and we don't need the true ones as they accept everything\n    schemas = schemas.filter(isPlainObject)\n\n    const allKeys = allUniqueKeys(schemas)\n    if (options.deep && contains(allKeys, 'allOf')) {\n      return merger({\n        allOf: schemas\n      }, options, totalSchemas)\n    }\n\n    const complexKeysArr = complexResolvers.map(([mainKeyWord, resolverConf]) =>\n      allKeys.filter(k => resolverConf.keywords.includes(k)))\n\n    // remove all complex keys before simple resolvers\n    complexKeysArr.forEach(keys => pullAll(allKeys, keys))\n\n    // call all simple resolvers for relevant keywords\n    allKeys.forEach(function(key) {\n      const values = getValues(schemas, key)\n      const compacted = uniqWith(values.filter(notUndefined), compareProp(key))\n\n      // arrayprops like anyOf and oneOf must be merged first, as they contains schemas\n      // allOf is treated differently alltogether\n      if (compacted.length === 1 && contains(schemaArrays, key)) {\n        merged[key] = compacted[0].map(schema => mergeSchemas([schema], schema))\n        // prop groups must always be resolved\n      } else if (compacted.length === 1 && !contains(schemaGroupProps, key) && !contains(schemaProps, key)) {\n        merged[key] = compacted[0]\n      } else {\n        const resolver = options.resolvers[key] || options.resolvers.defaultResolver\n        if (!resolver) throw new Error('No resolver found for key ' + key + '. You can provide a resolver for this keyword in the options, or provide a default resolver.')\n\n        const merger = (schemas, extraKey = []) => mergeSchemas(schemas, null, parents.concat(key, extraKey))\n        merged[key] = resolver(compacted, parents.concat(key), merger, options)\n\n        if (merged[key] === undefined) {\n          throwIncompatible(compacted, parents.concat(key))\n        } else if (merged[key] === undefined) {\n          delete merged[key]\n        }\n      }\n    })\n\n    return complexResolvers.reduce((all, [resolverKeyword, config], index) => ({\n      ...all,\n      ...callGroupResolver(complexKeysArr[index], resolverKeyword, schemas, mergeSchemas, options, parents)\n    }), merged)\n  }\n\n  const allSchemas = flattenDeep(getAllOf(rootSchema))\n  const merged = mergeSchemas(allSchemas)\n\n  return merged\n}\n\nmerger.options = {\n  resolvers: defaultResolvers\n}\n\nmodule.exports = merger\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLW1lcmdlLWFsbG9mL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyxzRUFBa0I7QUFDNUMsZ0JBQWdCLG1CQUFPLENBQUMsc0ZBQXFCO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLHNFQUFhO0FBQ3hDLHFCQUFxQixtQkFBTyxDQUFDLDRFQUFxQjtBQUNsRCxnQkFBZ0IsbUJBQU8sQ0FBQyxrRUFBZ0I7QUFDeEMsb0JBQW9CLG1CQUFPLENBQUMsMEVBQW9CO0FBQ2hELHFCQUFxQixtQkFBTyxDQUFDLDRFQUFxQjtBQUNsRCx5QkFBeUIsbUJBQU8sQ0FBQyxvRkFBeUI7QUFDMUQsZ0JBQWdCLG1CQUFPLENBQUMsa0VBQWdCO0FBQ3hDLHNCQUFzQixtQkFBTyxDQUFDLDhFQUFzQjtBQUNwRCxnQkFBZ0IsbUJBQU8sQ0FBQyxrRUFBZ0I7QUFDeEMsZUFBZSxtQkFBTyxDQUFDLGdFQUFlO0FBQ3RDLGFBQWEsbUJBQU8sQ0FBQyw0REFBYTtBQUNsQyxpQkFBaUIsbUJBQU8sQ0FBQyxvRUFBaUI7O0FBRTFDLDJCQUEyQixtQkFBTyxDQUFDLDRIQUFnQztBQUNuRSxzQkFBc0IsbUJBQU8sQ0FBQyxrSEFBMkI7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUksVUFBVTtBQUNuQjtBQUNBOztBQUVBO0FBQ0EsUUFBUSxzQkFBc0I7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxLQUFLOztBQUVWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLW1lcmdlLWFsbG9mL3NyYy9pbmRleC5qcz8xZGZlIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNsb25lRGVlcCA9IHJlcXVpcmUoJ2xvZGFzaC9jbG9uZURlZXAnKVxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJ2pzb24tc2NoZW1hLWNvbXBhcmUnKVxuY29uc3QgY29tcHV0ZUxjbSA9IHJlcXVpcmUoJ2NvbXB1dGUtbGNtJylcbmNvbnN0IGRlZmF1bHRzRGVlcCA9IHJlcXVpcmUoJ2xvZGFzaC9kZWZhdWx0c0RlZXAnKVxuY29uc3QgZmxhdHRlbiA9IHJlcXVpcmUoJ2xvZGFzaC9mbGF0dGVuJylcbmNvbnN0IGZsYXR0ZW5EZWVwID0gcmVxdWlyZSgnbG9kYXNoL2ZsYXR0ZW5EZWVwJylcbmNvbnN0IGludGVyc2VjdGlvbiA9IHJlcXVpcmUoJ2xvZGFzaC9pbnRlcnNlY3Rpb24nKVxuY29uc3QgaW50ZXJzZWN0aW9uV2l0aCA9IHJlcXVpcmUoJ2xvZGFzaC9pbnRlcnNlY3Rpb25XaXRoJylcbmNvbnN0IGlzRXF1YWwgPSByZXF1aXJlKCdsb2Rhc2gvaXNFcXVhbCcpXG5jb25zdCBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzUGxhaW5PYmplY3QnKVxuY29uc3QgcHVsbEFsbCA9IHJlcXVpcmUoJ2xvZGFzaC9wdWxsQWxsJylcbmNvbnN0IHNvcnRCeSA9IHJlcXVpcmUoJ2xvZGFzaC9zb3J0QnknKVxuY29uc3QgdW5pcSA9IHJlcXVpcmUoJ2xvZGFzaC91bmlxJylcbmNvbnN0IHVuaXFXaXRoID0gcmVxdWlyZSgnbG9kYXNoL3VuaXFXaXRoJylcblxuY29uc3QgcHJvcGVydGllc1Jlc29sdmVyID0gcmVxdWlyZSgnLi9jb21wbGV4LXJlc29sdmVycy9wcm9wZXJ0aWVzJylcbmNvbnN0IGl0ZW1zUmVzb2x2ZXIgPSByZXF1aXJlKCcuL2NvbXBsZXgtcmVzb2x2ZXJzL2l0ZW1zJylcblxuY29uc3QgY29udGFpbnMgPSAoYXJyLCB2YWwpID0+IGFyci5pbmRleE9mKHZhbCkgIT09IC0xXG5jb25zdCBpc1NjaGVtYSA9ICh2YWwpID0+IGlzUGxhaW5PYmplY3QodmFsKSB8fCB2YWwgPT09IHRydWUgfHwgdmFsID09PSBmYWxzZVxuY29uc3QgaXNGYWxzZSA9ICh2YWwpID0+IHZhbCA9PT0gZmFsc2VcbmNvbnN0IGlzVHJ1ZSA9ICh2YWwpID0+IHZhbCA9PT0gdHJ1ZVxuY29uc3Qgc2NoZW1hUmVzb2x2ZXIgPSAoY29tcGFjdGVkLCBrZXksIG1lcmdlU2NoZW1hcykgPT4gbWVyZ2VTY2hlbWFzKGNvbXBhY3RlZClcbmNvbnN0IHN0cmluZ0FycmF5ID0gKHZhbHVlcykgPT4gc29ydEJ5KHVuaXEoZmxhdHRlbkRlZXAodmFsdWVzKSkpXG5jb25zdCBub3RVbmRlZmluZWQgPSAodmFsKSA9PiB2YWwgIT09IHVuZGVmaW5lZFxuY29uc3QgYWxsVW5pcXVlS2V5cyA9IChhcnIpID0+IHVuaXEoZmxhdHRlbkRlZXAoYXJyLm1hcChrZXlzKSkpXG5cbi8vIHJlc29sdmVyc1xuY29uc3QgZmlyc3QgPSBjb21wYWN0ZWQgPT4gY29tcGFjdGVkWzBdXG5jb25zdCByZXF1aXJlZCA9IGNvbXBhY3RlZCA9PiBzdHJpbmdBcnJheShjb21wYWN0ZWQpXG5jb25zdCBtYXhpbXVtVmFsdWUgPSBjb21wYWN0ZWQgPT4gTWF0aC5tYXguYXBwbHkoTWF0aCwgY29tcGFjdGVkKVxuY29uc3QgbWluaW11bVZhbHVlID0gY29tcGFjdGVkID0+IE1hdGgubWluLmFwcGx5KE1hdGgsIGNvbXBhY3RlZClcbmNvbnN0IHVuaXF1ZUl0ZW1zID0gY29tcGFjdGVkID0+IGNvbXBhY3RlZC5zb21lKGlzVHJ1ZSlcbmNvbnN0IGV4YW1wbGVzID0gY29tcGFjdGVkID0+IHVuaXFXaXRoKGZsYXR0ZW4oY29tcGFjdGVkKSwgaXNFcXVhbClcblxuZnVuY3Rpb24gY29tcGFyZVByb3Aoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUoe1xuICAgICAgW2tleV06IGFcbiAgICB9LCB7IFtrZXldOiBiIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QWxsT2Yoc2NoZW1hKSB7XG4gIGxldCB7IGFsbE9mID0gW10sIC4uLmNvcHkgfSA9IHNjaGVtYVxuICBjb3B5ID0gaXNQbGFpbk9iamVjdChzY2hlbWEpID8gY29weSA6IHNjaGVtYSAvLyBpZiBzY2hlbWEgaXMgYm9vbGVhblxuICByZXR1cm4gW2NvcHksIC4uLmFsbE9mLm1hcChnZXRBbGxPZildXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlcyhzY2hlbWFzLCBrZXkpIHtcbiAgcmV0dXJuIHNjaGVtYXMubWFwKHNjaGVtYSA9PiBzY2hlbWEgJiYgc2NoZW1hW2tleV0pXG59XG5cbmZ1bmN0aW9uIHRyeU1lcmdlU2NoZW1hR3JvdXBzKHNjaGVtYUdyb3VwcywgbWVyZ2VTY2hlbWFzKSB7XG4gIHJldHVybiBzY2hlbWFHcm91cHMubWFwKGZ1bmN0aW9uKHNjaGVtYXMsIGluZGV4KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBtZXJnZVNjaGVtYXMoc2NoZW1hcywgaW5kZXgpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgfSkuZmlsdGVyKG5vdFVuZGVmaW5lZClcbn1cblxuZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgaWYgKGlzUGxhaW5PYmplY3Qob2JqKSB8fCBBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFueU9mQ29tYmluYXRpb25zKGFyck9mQXJyYXlzLCBjb21iaW5hdGlvbnMpIHtcbiAgY29tYmluYXRpb25zID0gY29tYmluYXRpb25zIHx8IFtdXG4gIGlmICghYXJyT2ZBcnJheXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNvbWJpbmF0aW9uc1xuICB9XG5cbiAgY29uc3QgdmFsdWVzID0gYXJyT2ZBcnJheXMuc2xpY2UoMCkuc2hpZnQoKVxuICBjb25zdCByZXN0ID0gYXJyT2ZBcnJheXMuc2xpY2UoMSlcbiAgaWYgKGNvbWJpbmF0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZ2V0QW55T2ZDb21iaW5hdGlvbnMocmVzdCwgZmxhdHRlbihjb21iaW5hdGlvbnMubWFwKGNvbWJpbmF0aW9uID0+IHZhbHVlcy5tYXAoaXRlbSA9PiAoW2l0ZW1dLmNvbmNhdChjb21iaW5hdGlvbikpKSkpKVxuICB9XG4gIHJldHVybiBnZXRBbnlPZkNvbWJpbmF0aW9ucyhyZXN0LCB2YWx1ZXMubWFwKGl0ZW0gPT4gKGl0ZW0pKSlcbn1cblxuZnVuY3Rpb24gdGhyb3dJbmNvbXBhdGlibGUodmFsdWVzLCBwYXRocykge1xuICBsZXQgYXNKU09OXG4gIHRyeSB7XG4gICAgYXNKU09OID0gdmFsdWVzLm1hcChmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgfSkuam9pbignXFxuJylcbiAgfSBjYXRjaCAodmFyaWFibGUpIHtcbiAgICBhc0pTT04gPSB2YWx1ZXMuam9pbignLCAnKVxuICB9XG4gIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJlc29sdmUgdmFsdWVzIGZvciBwYXRoOlwiJyArIHBhdGhzLmpvaW4oJy4nKSArICdcIi4gVGhleSBhcmUgcHJvYmFibHkgaW5jb21wYXRpYmxlLiBWYWx1ZXM6IFxcbicgKyBhc0pTT04pXG59XG5cbmZ1bmN0aW9uIGNhbGxHcm91cFJlc29sdmVyKGNvbXBsZXhLZXl3b3JkcywgcmVzb2x2ZXJOYW1lLCBzY2hlbWFzLCBtZXJnZVNjaGVtYXMsIG9wdGlvbnMsIHBhcmVudHMpIHtcbiAgaWYgKGNvbXBsZXhLZXl3b3Jkcy5sZW5ndGgpIHtcbiAgICBjb25zdCByZXNvbHZlckNvbmZpZyA9IG9wdGlvbnMuY29tcGxleFJlc29sdmVyc1tyZXNvbHZlck5hbWVdXG4gICAgaWYgKCFyZXNvbHZlckNvbmZpZyB8fCAhcmVzb2x2ZXJDb25maWcucmVzb2x2ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcmVzb2x2ZXIgZm91bmQgZm9yICcgKyByZXNvbHZlck5hbWUpXG4gICAgfVxuXG4gICAgLy8gZXh0cmFjdCBhbGwga2V5d29yZHMgZnJvbSBhbGwgdGhlIHNjaGVtYXMgdGhhdCBoYXZlIG9uZSBvciBtb3JlXG4gICAgLy8gdGhlbiByZW1vdmUgYWxsIHVuZGVmaW5lZCBvbmVzIGFuZCBub3QgdW5pcXVlXG4gICAgY29uc3QgZXh0cmFjdGVkS2V5d29yZHNPbmx5ID0gc2NoZW1hcy5tYXAoc2NoZW1hID0+IGNvbXBsZXhLZXl3b3Jkcy5yZWR1Y2UoKGFsbCwga2V5KSA9PiB7XG4gICAgICBpZiAoc2NoZW1hW2tleV0gIT09IHVuZGVmaW5lZCkgYWxsW2tleV0gPSBzY2hlbWFba2V5XVxuICAgICAgcmV0dXJuIGFsbFxuICAgIH0sIHt9KSlcbiAgICBjb25zdCB1bmlxdWUgPSB1bmlxV2l0aChleHRyYWN0ZWRLZXl3b3Jkc09ubHksIGNvbXBhcmUpXG5cbiAgICAvLyBjcmVhdGUgbWVyZ2VycyB0aGF0IGF1dG9tYXRpY2FsbHkgYWRkIHRoZSBwYXRoIG9mIHRoZSBrZXl3b3JkIGZvciB1c2UgaW4gdGhlIGNvbXBsZXggcmVzb2x2ZXJcbiAgICBjb25zdCBtZXJnZXJzID0gcmVzb2x2ZXJDb25maWcua2V5d29yZHMucmVkdWNlKChhbGwsIGtleSkgPT4gKHtcbiAgICAgIC4uLmFsbCxcbiAgICAgIFtrZXldOiAoc2NoZW1hcywgZXh0cmFLZXkgPSBbXSkgPT4gbWVyZ2VTY2hlbWFzKHNjaGVtYXMsIG51bGwsIHBhcmVudHMuY29uY2F0KGtleSwgZXh0cmFLZXkpKVxuICAgIH0pLCB7fSlcblxuICAgIGNvbnN0IHJlc3VsdCA9IHJlc29sdmVyQ29uZmlnLnJlc29sdmVyKHVuaXF1ZSwgcGFyZW50cy5jb25jYXQocmVzb2x2ZXJOYW1lKSwgbWVyZ2Vycywgb3B0aW9ucylcblxuICAgIGlmICghaXNQbGFpbk9iamVjdChyZXN1bHQpKSB7XG4gICAgICB0aHJvd0luY29tcGF0aWJsZSh1bmlxdWUsIHBhcmVudHMuY29uY2F0KHJlc29sdmVyTmFtZSkpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlcXVpcmVkTWV0YUFycmF5KGFycikge1xuICByZXR1cm4geyByZXF1aXJlZDogYXJyIH1cbn1cblxuY29uc3Qgc2NoZW1hR3JvdXBQcm9wcyA9IFsncHJvcGVydGllcycsICdwYXR0ZXJuUHJvcGVydGllcycsICdkZWZpbml0aW9ucycsICdkZXBlbmRlbmNpZXMnXVxuY29uc3Qgc2NoZW1hQXJyYXlzID0gWydhbnlPZicsICdvbmVPZiddXG5jb25zdCBzY2hlbWFQcm9wcyA9IFtcbiAgJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJyxcbiAgJ2FkZGl0aW9uYWxJdGVtcycsXG4gICdjb250YWlucycsXG4gICdwcm9wZXJ0eU5hbWVzJyxcbiAgJ25vdCcsXG4gICdpdGVtcydcbl1cblxuY29uc3QgZGVmYXVsdFJlc29sdmVycyA9IHtcbiAgdHlwZShjb21wYWN0ZWQpIHtcbiAgICBpZiAoY29tcGFjdGVkLnNvbWUoQXJyYXkuaXNBcnJheSkpIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBjb21wYWN0ZWQubWFwKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpXG4gICAgICAgICAgPyB2YWxcbiAgICAgICAgICA6IFt2YWxdXG4gICAgICB9KVxuICAgICAgY29uc3QgY29tbW9uID0gaW50ZXJzZWN0aW9uLmFwcGx5KG51bGwsIG5vcm1hbGl6ZWQpXG5cbiAgICAgIGlmIChjb21tb24ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBjb21tb25bMF1cbiAgICAgIH0gZWxzZSBpZiAoY29tbW9uLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIHVuaXEoY29tbW9uKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZGVwZW5kZW5jaWVzKGNvbXBhY3RlZCwgcGF0aHMsIG1lcmdlU2NoZW1hcykge1xuICAgIGNvbnN0IGFsbENoaWxkcmVuID0gYWxsVW5pcXVlS2V5cyhjb21wYWN0ZWQpXG5cbiAgICByZXR1cm4gYWxsQ2hpbGRyZW4ucmVkdWNlKGZ1bmN0aW9uKGFsbCwgY2hpbGRLZXkpIHtcbiAgICAgIGNvbnN0IGNoaWxkU2NoZW1hcyA9IGdldFZhbHVlcyhjb21wYWN0ZWQsIGNoaWxkS2V5KVxuICAgICAgbGV0IGlubmVyQ29tcGFjdGVkID0gdW5pcVdpdGgoY2hpbGRTY2hlbWFzLmZpbHRlcihub3RVbmRlZmluZWQpLCBpc0VxdWFsKVxuXG4gICAgICAvLyB0byBzdXBwb3J0IGRlcGVuZGVuY2llc1xuICAgICAgY29uc3QgaW5uZXJBcnJheXMgPSBpbm5lckNvbXBhY3RlZC5maWx0ZXIoQXJyYXkuaXNBcnJheSlcblxuICAgICAgaWYgKGlubmVyQXJyYXlzLmxlbmd0aCkge1xuICAgICAgICBpZiAoaW5uZXJBcnJheXMubGVuZ3RoID09PSBpbm5lckNvbXBhY3RlZC5sZW5ndGgpIHtcbiAgICAgICAgICBhbGxbY2hpbGRLZXldID0gc3RyaW5nQXJyYXkoaW5uZXJDb21wYWN0ZWQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgaW5uZXJTY2hlbWFzID0gaW5uZXJDb21wYWN0ZWQuZmlsdGVyKGlzU2NoZW1hKVxuICAgICAgICAgIGNvbnN0IGFycmF5TWV0YVNjaGVhbXMgPSBpbm5lckFycmF5cy5tYXAoY3JlYXRlUmVxdWlyZWRNZXRhQXJyYXkpXG4gICAgICAgICAgYWxsW2NoaWxkS2V5XSA9IG1lcmdlU2NoZW1hcyhpbm5lclNjaGVtYXMuY29uY2F0KGFycmF5TWV0YVNjaGVhbXMpLCBjaGlsZEtleSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxsXG4gICAgICB9XG5cbiAgICAgIGlubmVyQ29tcGFjdGVkID0gdW5pcVdpdGgoaW5uZXJDb21wYWN0ZWQsIGNvbXBhcmUpXG5cbiAgICAgIGFsbFtjaGlsZEtleV0gPSBtZXJnZVNjaGVtYXMoaW5uZXJDb21wYWN0ZWQsIGNoaWxkS2V5KVxuICAgICAgcmV0dXJuIGFsbFxuICAgIH0sIHt9KVxuICB9LFxuICBvbmVPZihjb21wYWN0ZWQsIHBhdGhzLCBtZXJnZVNjaGVtYXMpIHtcbiAgICBjb25zdCBjb21iaW5hdGlvbnMgPSBnZXRBbnlPZkNvbWJpbmF0aW9ucyhjbG9uZURlZXAoY29tcGFjdGVkKSlcbiAgICBjb25zdCByZXN1bHQgPSB0cnlNZXJnZVNjaGVtYUdyb3Vwcyhjb21iaW5hdGlvbnMsIG1lcmdlU2NoZW1hcylcbiAgICBjb25zdCB1bmlxdWUgPSB1bmlxV2l0aChyZXN1bHQsIGNvbXBhcmUpXG5cbiAgICBpZiAodW5pcXVlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHVuaXF1ZVxuICAgIH1cbiAgfSxcbiAgbm90KGNvbXBhY3RlZCkge1xuICAgIHJldHVybiB7IGFueU9mOiBjb21wYWN0ZWQgfVxuICB9LFxuICBwYXR0ZXJuKGNvbXBhY3RlZCkge1xuICAgIHJldHVybiBjb21wYWN0ZWQubWFwKHIgPT4gJyg/PScgKyByICsgJyknKS5qb2luKCcnKVxuICB9LFxuICBtdWx0aXBsZU9mKGNvbXBhY3RlZCkge1xuICAgIGxldCBpbnRlZ2VycyA9IGNvbXBhY3RlZC5zbGljZSgwKVxuICAgIGxldCBmYWN0b3IgPSAxXG4gICAgd2hpbGUgKGludGVnZXJzLnNvbWUobiA9PiAhTnVtYmVyLmlzSW50ZWdlcihuKSkpIHtcbiAgICAgIGludGVnZXJzID0gaW50ZWdlcnMubWFwKG4gPT4gbiAqIDEwKVxuICAgICAgZmFjdG9yID0gZmFjdG9yICogMTBcbiAgICB9XG4gICAgcmV0dXJuIGNvbXB1dGVMY20oaW50ZWdlcnMpIC8gZmFjdG9yXG4gIH0sXG4gIGVudW0oY29tcGFjdGVkKSB7XG4gICAgY29uc3QgZW51bXMgPSBpbnRlcnNlY3Rpb25XaXRoLmFwcGx5KG51bGwsIGNvbXBhY3RlZC5jb25jYXQoaXNFcXVhbCkpXG4gICAgaWYgKGVudW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHNvcnRCeShlbnVtcylcbiAgICB9XG4gIH1cbn1cblxuZGVmYXVsdFJlc29sdmVycy4kaWQgPSBmaXJzdFxuZGVmYXVsdFJlc29sdmVycy4kcmVmID0gZmlyc3RcbmRlZmF1bHRSZXNvbHZlcnMuJHNjaGVtYSA9IGZpcnN0XG5kZWZhdWx0UmVzb2x2ZXJzLmFkZGl0aW9uYWxJdGVtcyA9IHNjaGVtYVJlc29sdmVyXG5kZWZhdWx0UmVzb2x2ZXJzLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gc2NoZW1hUmVzb2x2ZXJcbmRlZmF1bHRSZXNvbHZlcnMuYW55T2YgPSBkZWZhdWx0UmVzb2x2ZXJzLm9uZU9mXG5kZWZhdWx0UmVzb2x2ZXJzLmNvbnRhaW5zID0gc2NoZW1hUmVzb2x2ZXJcbmRlZmF1bHRSZXNvbHZlcnMuZGVmYXVsdCA9IGZpcnN0XG5kZWZhdWx0UmVzb2x2ZXJzLmRlZmluaXRpb25zID0gZGVmYXVsdFJlc29sdmVycy5kZXBlbmRlbmNpZXNcbmRlZmF1bHRSZXNvbHZlcnMuZGVzY3JpcHRpb24gPSBmaXJzdFxuZGVmYXVsdFJlc29sdmVycy5leGFtcGxlcyA9IGV4YW1wbGVzXG5kZWZhdWx0UmVzb2x2ZXJzLmV4Y2x1c2l2ZU1heGltdW0gPSBtaW5pbXVtVmFsdWVcbmRlZmF1bHRSZXNvbHZlcnMuZXhjbHVzaXZlTWluaW11bSA9IG1heGltdW1WYWx1ZVxuZGVmYXVsdFJlc29sdmVycy5pdGVtcyA9IGl0ZW1zUmVzb2x2ZXJcbmRlZmF1bHRSZXNvbHZlcnMubWF4aW11bSA9IG1pbmltdW1WYWx1ZVxuZGVmYXVsdFJlc29sdmVycy5tYXhJdGVtcyA9IG1pbmltdW1WYWx1ZVxuZGVmYXVsdFJlc29sdmVycy5tYXhMZW5ndGggPSBtaW5pbXVtVmFsdWVcbmRlZmF1bHRSZXNvbHZlcnMubWF4UHJvcGVydGllcyA9IG1pbmltdW1WYWx1ZVxuZGVmYXVsdFJlc29sdmVycy5taW5pbXVtID0gbWF4aW11bVZhbHVlXG5kZWZhdWx0UmVzb2x2ZXJzLm1pbkl0ZW1zID0gbWF4aW11bVZhbHVlXG5kZWZhdWx0UmVzb2x2ZXJzLm1pbkxlbmd0aCA9IG1heGltdW1WYWx1ZVxuZGVmYXVsdFJlc29sdmVycy5taW5Qcm9wZXJ0aWVzID0gbWF4aW11bVZhbHVlXG5kZWZhdWx0UmVzb2x2ZXJzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzUmVzb2x2ZXJcbmRlZmF1bHRSZXNvbHZlcnMucHJvcGVydHlOYW1lcyA9IHNjaGVtYVJlc29sdmVyXG5kZWZhdWx0UmVzb2x2ZXJzLnJlcXVpcmVkID0gcmVxdWlyZWRcbmRlZmF1bHRSZXNvbHZlcnMudGl0bGUgPSBmaXJzdFxuZGVmYXVsdFJlc29sdmVycy51bmlxdWVJdGVtcyA9IHVuaXF1ZUl0ZW1zXG5cbmNvbnN0IGRlZmF1bHRDb21wbGV4UmVzb2x2ZXJzID0ge1xuICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzUmVzb2x2ZXIsXG4gIGl0ZW1zOiBpdGVtc1Jlc29sdmVyXG59XG5cbmZ1bmN0aW9uIG1lcmdlcihyb290U2NoZW1hLCBvcHRpb25zLCB0b3RhbFNjaGVtYXMpIHtcbiAgdG90YWxTY2hlbWFzID0gdG90YWxTY2hlbWFzIHx8IFtdXG4gIG9wdGlvbnMgPSBkZWZhdWx0c0RlZXAob3B0aW9ucywge1xuICAgIGlnbm9yZUFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICByZXNvbHZlcnM6IGRlZmF1bHRSZXNvbHZlcnMsXG4gICAgY29tcGxleFJlc29sdmVyczogZGVmYXVsdENvbXBsZXhSZXNvbHZlcnMsXG4gICAgZGVlcDogdHJ1ZVxuICB9KVxuXG4gIGNvbnN0IGNvbXBsZXhSZXNvbHZlcnMgPSBPYmplY3QuZW50cmllcyhvcHRpb25zLmNvbXBsZXhSZXNvbHZlcnMpXG5cbiAgZnVuY3Rpb24gbWVyZ2VTY2hlbWFzKHNjaGVtYXMsIGJhc2UsIHBhcmVudHMpIHtcbiAgICBzY2hlbWFzID0gY2xvbmVEZWVwKHNjaGVtYXMuZmlsdGVyKG5vdFVuZGVmaW5lZCkpXG4gICAgcGFyZW50cyA9IHBhcmVudHMgfHwgW11cbiAgICBjb25zdCBtZXJnZWQgPSBpc1BsYWluT2JqZWN0KGJhc2UpXG4gICAgICA/IGJhc2VcbiAgICAgIDoge31cblxuICAgIC8vIHJldHVybiB1bmRlZmluZWQsIGFuIGVtcHR5IHNjaGVtYVxuICAgIGlmICghc2NoZW1hcy5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChzY2hlbWFzLnNvbWUoaXNGYWxzZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChzY2hlbWFzLmV2ZXJ5KGlzVHJ1ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gdGhlcmUgYXJlIG5vIGZhbHNlIGFuZCB3ZSBkb24ndCBuZWVkIHRoZSB0cnVlIG9uZXMgYXMgdGhleSBhY2NlcHQgZXZlcnl0aGluZ1xuICAgIHNjaGVtYXMgPSBzY2hlbWFzLmZpbHRlcihpc1BsYWluT2JqZWN0KVxuXG4gICAgY29uc3QgYWxsS2V5cyA9IGFsbFVuaXF1ZUtleXMoc2NoZW1hcylcbiAgICBpZiAob3B0aW9ucy5kZWVwICYmIGNvbnRhaW5zKGFsbEtleXMsICdhbGxPZicpKSB7XG4gICAgICByZXR1cm4gbWVyZ2VyKHtcbiAgICAgICAgYWxsT2Y6IHNjaGVtYXNcbiAgICAgIH0sIG9wdGlvbnMsIHRvdGFsU2NoZW1hcylcbiAgICB9XG5cbiAgICBjb25zdCBjb21wbGV4S2V5c0FyciA9IGNvbXBsZXhSZXNvbHZlcnMubWFwKChbbWFpbktleVdvcmQsIHJlc29sdmVyQ29uZl0pID0+XG4gICAgICBhbGxLZXlzLmZpbHRlcihrID0+IHJlc29sdmVyQ29uZi5rZXl3b3Jkcy5pbmNsdWRlcyhrKSkpXG5cbiAgICAvLyByZW1vdmUgYWxsIGNvbXBsZXgga2V5cyBiZWZvcmUgc2ltcGxlIHJlc29sdmVyc1xuICAgIGNvbXBsZXhLZXlzQXJyLmZvckVhY2goa2V5cyA9PiBwdWxsQWxsKGFsbEtleXMsIGtleXMpKVxuXG4gICAgLy8gY2FsbCBhbGwgc2ltcGxlIHJlc29sdmVycyBmb3IgcmVsZXZhbnQga2V5d29yZHNcbiAgICBhbGxLZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBnZXRWYWx1ZXMoc2NoZW1hcywga2V5KVxuICAgICAgY29uc3QgY29tcGFjdGVkID0gdW5pcVdpdGgodmFsdWVzLmZpbHRlcihub3RVbmRlZmluZWQpLCBjb21wYXJlUHJvcChrZXkpKVxuXG4gICAgICAvLyBhcnJheXByb3BzIGxpa2UgYW55T2YgYW5kIG9uZU9mIG11c3QgYmUgbWVyZ2VkIGZpcnN0LCBhcyB0aGV5IGNvbnRhaW5zIHNjaGVtYXNcbiAgICAgIC8vIGFsbE9mIGlzIHRyZWF0ZWQgZGlmZmVyZW50bHkgYWxsdG9nZXRoZXJcbiAgICAgIGlmIChjb21wYWN0ZWQubGVuZ3RoID09PSAxICYmIGNvbnRhaW5zKHNjaGVtYUFycmF5cywga2V5KSkge1xuICAgICAgICBtZXJnZWRba2V5XSA9IGNvbXBhY3RlZFswXS5tYXAoc2NoZW1hID0+IG1lcmdlU2NoZW1hcyhbc2NoZW1hXSwgc2NoZW1hKSlcbiAgICAgICAgLy8gcHJvcCBncm91cHMgbXVzdCBhbHdheXMgYmUgcmVzb2x2ZWRcbiAgICAgIH0gZWxzZSBpZiAoY29tcGFjdGVkLmxlbmd0aCA9PT0gMSAmJiAhY29udGFpbnMoc2NoZW1hR3JvdXBQcm9wcywga2V5KSAmJiAhY29udGFpbnMoc2NoZW1hUHJvcHMsIGtleSkpIHtcbiAgICAgICAgbWVyZ2VkW2tleV0gPSBjb21wYWN0ZWRbMF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gb3B0aW9ucy5yZXNvbHZlcnNba2V5XSB8fCBvcHRpb25zLnJlc29sdmVycy5kZWZhdWx0UmVzb2x2ZXJcbiAgICAgICAgaWYgKCFyZXNvbHZlcikgdGhyb3cgbmV3IEVycm9yKCdObyByZXNvbHZlciBmb3VuZCBmb3Iga2V5ICcgKyBrZXkgKyAnLiBZb3UgY2FuIHByb3ZpZGUgYSByZXNvbHZlciBmb3IgdGhpcyBrZXl3b3JkIGluIHRoZSBvcHRpb25zLCBvciBwcm92aWRlIGEgZGVmYXVsdCByZXNvbHZlci4nKVxuXG4gICAgICAgIGNvbnN0IG1lcmdlciA9IChzY2hlbWFzLCBleHRyYUtleSA9IFtdKSA9PiBtZXJnZVNjaGVtYXMoc2NoZW1hcywgbnVsbCwgcGFyZW50cy5jb25jYXQoa2V5LCBleHRyYUtleSkpXG4gICAgICAgIG1lcmdlZFtrZXldID0gcmVzb2x2ZXIoY29tcGFjdGVkLCBwYXJlbnRzLmNvbmNhdChrZXkpLCBtZXJnZXIsIG9wdGlvbnMpXG5cbiAgICAgICAgaWYgKG1lcmdlZFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvd0luY29tcGF0aWJsZShjb21wYWN0ZWQsIHBhcmVudHMuY29uY2F0KGtleSkpXG4gICAgICAgIH0gZWxzZSBpZiAobWVyZ2VkW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRlbGV0ZSBtZXJnZWRba2V5XVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBjb21wbGV4UmVzb2x2ZXJzLnJlZHVjZSgoYWxsLCBbcmVzb2x2ZXJLZXl3b3JkLCBjb25maWddLCBpbmRleCkgPT4gKHtcbiAgICAgIC4uLmFsbCxcbiAgICAgIC4uLmNhbGxHcm91cFJlc29sdmVyKGNvbXBsZXhLZXlzQXJyW2luZGV4XSwgcmVzb2x2ZXJLZXl3b3JkLCBzY2hlbWFzLCBtZXJnZVNjaGVtYXMsIG9wdGlvbnMsIHBhcmVudHMpXG4gICAgfSksIG1lcmdlZClcbiAgfVxuXG4gIGNvbnN0IGFsbFNjaGVtYXMgPSBmbGF0dGVuRGVlcChnZXRBbGxPZihyb290U2NoZW1hKSlcbiAgY29uc3QgbWVyZ2VkID0gbWVyZ2VTY2hlbWFzKGFsbFNjaGVtYXMpXG5cbiAgcmV0dXJuIG1lcmdlZFxufVxuXG5tZXJnZXIub3B0aW9ucyA9IHtcbiAgcmVzb2x2ZXJzOiBkZWZhdWx0UmVzb2x2ZXJzXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2VyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/json-schema-merge-allof/src/index.js\n");

/***/ })

};
;