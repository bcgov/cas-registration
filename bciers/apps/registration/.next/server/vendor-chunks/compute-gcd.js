"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/compute-gcd";
exports.ids = ["vendor-chunks/compute-gcd"];
exports.modules = {

/***/ "(ssr)/../../node_modules/compute-gcd/lib/index.js":
/*!***************************************************!*\
  !*** ../../node_modules/compute-gcd/lib/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n// MODULES //\n\nvar isArray = __webpack_require__( /*! validate.io-array */ \"(ssr)/../../node_modules/validate.io-array/lib/index.js\" ),\n\tisIntegerArray = __webpack_require__( /*! validate.io-integer-array */ \"(ssr)/../../node_modules/validate.io-integer-array/lib/index.js\" ),\n\tisFunction = __webpack_require__( /*! validate.io-function */ \"(ssr)/../../node_modules/validate.io-function/lib/index.js\" );\n\n\n// VARIABLES //\n\nvar MAXINT = Math.pow( 2, 31 ) - 1;\n\n\n// FUNCTIONS //\n\n/**\n* FUNCTION: gcd( a, b )\n*\tComputes the greatest common divisor of two integers `a` and `b`, using the binary GCD algorithm.\n*\n* @param {Number} a - integer\n* @param {Number} b - integer\n* @returns {Number} greatest common divisor\n*/\nfunction gcd( a, b ) {\n\tvar k = 1,\n\t\tt;\n\t// Simple cases:\n\tif ( a === 0 ) {\n\t\treturn b;\n\t}\n\tif ( b === 0 ) {\n\t\treturn a;\n\t}\n\t// Reduce `a` and/or `b` to odd numbers and keep track of the greatest power of 2 dividing both `a` and `b`...\n\twhile ( a%2 === 0 && b%2 === 0 ) {\n\t\ta = a / 2; // right shift\n\t\tb = b / 2; // right shift\n\t\tk = k * 2; // left shift\n\t}\n\t// Reduce `a` to an odd number...\n\twhile ( a%2 === 0 ) {\n\t\ta = a / 2; // right shift\n\t}\n\t// Henceforth, `a` is always odd...\n\twhile ( b ) {\n\t\t// Remove all factors of 2 in `b`, as they are not common...\n\t\twhile ( b%2 === 0 ) {\n\t\t\tb = b / 2; // right shift\n\t\t}\n\t\t// `a` and `b` are both odd. Swap values such that `b` is the larger of the two values, and then set `b` to the difference (which is even)...\n\t\tif ( a > b ) {\n\t\t\tt = b;\n\t\t\tb = a;\n\t\t\ta = t;\n\t\t}\n\t\tb = b - a; // b=0 iff b=a\n\t}\n\t// Restore common factors of 2...\n\treturn k * a;\n} // end FUNCTION gcd()\n\n/**\n* FUNCTION: bitwise( a, b )\n*\tComputes the greatest common divisor of two integers `a` and `b`, using the binary GCD algorithm and bitwise operations.\n*\n* @param {Number} a - safe integer\n* @param {Number} b - safe integer\n* @returns {Number} greatest common divisor\n*/\nfunction bitwise( a, b ) {\n\tvar k = 0,\n\t\tt;\n\t// Simple cases:\n\tif ( a === 0 ) {\n\t\treturn b;\n\t}\n\tif ( b === 0 ) {\n\t\treturn a;\n\t}\n\t// Reduce `a` and/or `b` to odd numbers and keep track of the greatest power of 2 dividing both `a` and `b`...\n\twhile ( (a & 1) === 0 && (b & 1) === 0 ) {\n\t\ta >>>= 1; // right shift\n\t\tb >>>= 1; // right shift\n\t\tk++;\n\t}\n\t// Reduce `a` to an odd number...\n\twhile ( (a & 1) === 0 ) {\n\t\ta >>>= 1; // right shift\n\t}\n\t// Henceforth, `a` is always odd...\n\twhile ( b ) {\n\t\t// Remove all factors of 2 in `b`, as they are not common...\n\t\twhile ( (b & 1) === 0 ) {\n\t\t\tb >>>= 1; // right shift\n\t\t}\n\t\t// `a` and `b` are both odd. Swap values such that `b` is the larger of the two values, and then set `b` to the difference (which is even)...\n\t\tif ( a > b ) {\n\t\t\tt = b;\n\t\t\tb = a;\n\t\t\ta = t;\n\t\t}\n\t\tb = b - a; // b=0 iff b=a\n\t}\n\t// Restore common factors of 2...\n\treturn a << k;\n} // end FUNCTION bitwise()\n\n\n// GREATEST COMMON DIVISOR //\n\n/**\n* FUNCTION: compute( arr[, clbk] )\n*\tComputes the greatest common divisor.\n*\n* @param {Number[]|Number} arr - input array of integers\n* @param {Function|Number} [clbk] - accessor function for accessing array values\n* @returns {Number|Null} greatest common divisor or null\n*/\nfunction compute() {\n\tvar nargs = arguments.length,\n\t\targs,\n\t\tclbk,\n\t\tarr,\n\t\tlen,\n\t\ta, b,\n\t\ti;\n\n\t// Copy the input arguments to an array...\n\targs = new Array( nargs );\n\tfor ( i = 0; i < nargs; i++ ) {\n\t\targs[ i ] = arguments[ i ];\n\t}\n\t// Have we been provided with integer arguments?\n\tif ( isIntegerArray( args ) ) {\n\t\tif ( nargs === 2 ) {\n\t\t\ta = args[ 0 ];\n\t\t\tb = args[ 1 ];\n\t\t\tif ( a < 0 ) {\n\t\t\t\ta = -a;\n\t\t\t}\n\t\t\tif ( b < 0 ) {\n\t\t\t\tb = -b;\n\t\t\t}\n\t\t\tif ( a <= MAXINT && b <= MAXINT ) {\n\t\t\t\treturn bitwise( a, b );\n\t\t\t} else {\n\t\t\t\treturn gcd( a, b );\n\t\t\t}\n\t\t}\n\t\tarr = args;\n\t}\n\t// If not integers, ensure the first argument is an array...\n\telse if ( !isArray( args[ 0 ] ) ) {\n\t\tthrow new TypeError( 'gcd()::invalid input argument. Must provide an array of integers. Value: `' + args[ 0 ] + '`.' );\n\t}\n\t// Have we been provided with more than one argument? If so, ensure that the accessor argument is a function...\n\telse if ( nargs > 1 ) {\n\t\tarr = args[ 0 ];\n\t\tclbk = args[ 1 ];\n\t\tif ( !isFunction( clbk ) ) {\n\t\t\tthrow new TypeError( 'gcd()::invalid input argument. Accessor must be a function. Value: `' + clbk + '`.' );\n\t\t}\n\t}\n\t// We have been provided an array...\n\telse {\n\t\tarr = args[ 0 ];\n\t}\n\tlen = arr.length;\n\n\t// Check if a sufficient number of values have been provided...\n\tif ( len < 2 ) {\n\t\treturn null;\n\t}\n\t// If an accessor is provided, extract the array values...\n\tif ( clbk ) {\n\t\ta = new Array( len );\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\ta[ i ] = clbk( arr[ i ], i );\n\t\t}\n\t\tarr = a;\n\t}\n\t// Given an input array, ensure all array values are integers...\n\tif ( nargs < 3 ) {\n\t\tif ( !isIntegerArray( arr ) ) {\n\t\t\tthrow new TypeError( 'gcd()::invalid input argument. Accessed array values must be integers. Value: `' + arr + '`.' );\n\t\t}\n\t}\n\t// Convert any negative integers to positive integers...\n\tfor ( i = 0; i < len; i++ ) {\n\t\ta = arr[ i ];\n\t\tif ( a < 0 ) {\n\t\t\tarr[ i ] = -a;\n\t\t}\n\t}\n\t// Exploit the fact that the gcd is an associative function...\n\ta = arr[ 0 ];\n\tfor ( i = 1; i < len; i++ ) {\n\t\tb = arr[ i ];\n\t\tif ( b <= MAXINT && a <= MAXINT ) {\n\t\t\ta = bitwise( a, b );\n\t\t} else {\n\t\t\ta = gcd( a, b );\n\t\t}\n\t}\n\treturn a;\n} // end FUNCTION compute()\n\n\n// EXPORTS //\n\nmodule.exports = compute;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2NvbXB1dGUtZ2NkL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQSxjQUFjLG1CQUFPLEVBQUUsa0ZBQW1CO0FBQzFDLGtCQUFrQixtQkFBTyxFQUFFLGtHQUEyQjtBQUN0RCxjQUFjLG1CQUFPLEVBQUUsd0ZBQXNCOzs7QUFHN0M7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQixVQUFVLGlCQUFpQjtBQUMzQixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbXB1dGUtZ2NkL2xpYi9pbmRleC5qcz8yY2U3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoICd2YWxpZGF0ZS5pby1hcnJheScgKSxcblx0aXNJbnRlZ2VyQXJyYXkgPSByZXF1aXJlKCAndmFsaWRhdGUuaW8taW50ZWdlci1hcnJheScgKSxcblx0aXNGdW5jdGlvbiA9IHJlcXVpcmUoICd2YWxpZGF0ZS5pby1mdW5jdGlvbicgKTtcblxuXG4vLyBWQVJJQUJMRVMgLy9cblxudmFyIE1BWElOVCA9IE1hdGgucG93KCAyLCAzMSApIC0gMTtcblxuXG4vLyBGVU5DVElPTlMgLy9cblxuLyoqXG4qIEZVTkNUSU9OOiBnY2QoIGEsIGIgKVxuKlx0Q29tcHV0ZXMgdGhlIGdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yIG9mIHR3byBpbnRlZ2VycyBgYWAgYW5kIGBiYCwgdXNpbmcgdGhlIGJpbmFyeSBHQ0QgYWxnb3JpdGhtLlxuKlxuKiBAcGFyYW0ge051bWJlcn0gYSAtIGludGVnZXJcbiogQHBhcmFtIHtOdW1iZXJ9IGIgLSBpbnRlZ2VyXG4qIEByZXR1cm5zIHtOdW1iZXJ9IGdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yXG4qL1xuZnVuY3Rpb24gZ2NkKCBhLCBiICkge1xuXHR2YXIgayA9IDEsXG5cdFx0dDtcblx0Ly8gU2ltcGxlIGNhc2VzOlxuXHRpZiAoIGEgPT09IDAgKSB7XG5cdFx0cmV0dXJuIGI7XG5cdH1cblx0aWYgKCBiID09PSAwICkge1xuXHRcdHJldHVybiBhO1xuXHR9XG5cdC8vIFJlZHVjZSBgYWAgYW5kL29yIGBiYCB0byBvZGQgbnVtYmVycyBhbmQga2VlcCB0cmFjayBvZiB0aGUgZ3JlYXRlc3QgcG93ZXIgb2YgMiBkaXZpZGluZyBib3RoIGBhYCBhbmQgYGJgLi4uXG5cdHdoaWxlICggYSUyID09PSAwICYmIGIlMiA9PT0gMCApIHtcblx0XHRhID0gYSAvIDI7IC8vIHJpZ2h0IHNoaWZ0XG5cdFx0YiA9IGIgLyAyOyAvLyByaWdodCBzaGlmdFxuXHRcdGsgPSBrICogMjsgLy8gbGVmdCBzaGlmdFxuXHR9XG5cdC8vIFJlZHVjZSBgYWAgdG8gYW4gb2RkIG51bWJlci4uLlxuXHR3aGlsZSAoIGElMiA9PT0gMCApIHtcblx0XHRhID0gYSAvIDI7IC8vIHJpZ2h0IHNoaWZ0XG5cdH1cblx0Ly8gSGVuY2Vmb3J0aCwgYGFgIGlzIGFsd2F5cyBvZGQuLi5cblx0d2hpbGUgKCBiICkge1xuXHRcdC8vIFJlbW92ZSBhbGwgZmFjdG9ycyBvZiAyIGluIGBiYCwgYXMgdGhleSBhcmUgbm90IGNvbW1vbi4uLlxuXHRcdHdoaWxlICggYiUyID09PSAwICkge1xuXHRcdFx0YiA9IGIgLyAyOyAvLyByaWdodCBzaGlmdFxuXHRcdH1cblx0XHQvLyBgYWAgYW5kIGBiYCBhcmUgYm90aCBvZGQuIFN3YXAgdmFsdWVzIHN1Y2ggdGhhdCBgYmAgaXMgdGhlIGxhcmdlciBvZiB0aGUgdHdvIHZhbHVlcywgYW5kIHRoZW4gc2V0IGBiYCB0byB0aGUgZGlmZmVyZW5jZSAod2hpY2ggaXMgZXZlbikuLi5cblx0XHRpZiAoIGEgPiBiICkge1xuXHRcdFx0dCA9IGI7XG5cdFx0XHRiID0gYTtcblx0XHRcdGEgPSB0O1xuXHRcdH1cblx0XHRiID0gYiAtIGE7IC8vIGI9MCBpZmYgYj1hXG5cdH1cblx0Ly8gUmVzdG9yZSBjb21tb24gZmFjdG9ycyBvZiAyLi4uXG5cdHJldHVybiBrICogYTtcbn0gLy8gZW5kIEZVTkNUSU9OIGdjZCgpXG5cbi8qKlxuKiBGVU5DVElPTjogYml0d2lzZSggYSwgYiApXG4qXHRDb21wdXRlcyB0aGUgZ3JlYXRlc3QgY29tbW9uIGRpdmlzb3Igb2YgdHdvIGludGVnZXJzIGBhYCBhbmQgYGJgLCB1c2luZyB0aGUgYmluYXJ5IEdDRCBhbGdvcml0aG0gYW5kIGJpdHdpc2Ugb3BlcmF0aW9ucy5cbipcbiogQHBhcmFtIHtOdW1iZXJ9IGEgLSBzYWZlIGludGVnZXJcbiogQHBhcmFtIHtOdW1iZXJ9IGIgLSBzYWZlIGludGVnZXJcbiogQHJldHVybnMge051bWJlcn0gZ3JlYXRlc3QgY29tbW9uIGRpdmlzb3JcbiovXG5mdW5jdGlvbiBiaXR3aXNlKCBhLCBiICkge1xuXHR2YXIgayA9IDAsXG5cdFx0dDtcblx0Ly8gU2ltcGxlIGNhc2VzOlxuXHRpZiAoIGEgPT09IDAgKSB7XG5cdFx0cmV0dXJuIGI7XG5cdH1cblx0aWYgKCBiID09PSAwICkge1xuXHRcdHJldHVybiBhO1xuXHR9XG5cdC8vIFJlZHVjZSBgYWAgYW5kL29yIGBiYCB0byBvZGQgbnVtYmVycyBhbmQga2VlcCB0cmFjayBvZiB0aGUgZ3JlYXRlc3QgcG93ZXIgb2YgMiBkaXZpZGluZyBib3RoIGBhYCBhbmQgYGJgLi4uXG5cdHdoaWxlICggKGEgJiAxKSA9PT0gMCAmJiAoYiAmIDEpID09PSAwICkge1xuXHRcdGEgPj4+PSAxOyAvLyByaWdodCBzaGlmdFxuXHRcdGIgPj4+PSAxOyAvLyByaWdodCBzaGlmdFxuXHRcdGsrKztcblx0fVxuXHQvLyBSZWR1Y2UgYGFgIHRvIGFuIG9kZCBudW1iZXIuLi5cblx0d2hpbGUgKCAoYSAmIDEpID09PSAwICkge1xuXHRcdGEgPj4+PSAxOyAvLyByaWdodCBzaGlmdFxuXHR9XG5cdC8vIEhlbmNlZm9ydGgsIGBhYCBpcyBhbHdheXMgb2RkLi4uXG5cdHdoaWxlICggYiApIHtcblx0XHQvLyBSZW1vdmUgYWxsIGZhY3RvcnMgb2YgMiBpbiBgYmAsIGFzIHRoZXkgYXJlIG5vdCBjb21tb24uLi5cblx0XHR3aGlsZSAoIChiICYgMSkgPT09IDAgKSB7XG5cdFx0XHRiID4+Pj0gMTsgLy8gcmlnaHQgc2hpZnRcblx0XHR9XG5cdFx0Ly8gYGFgIGFuZCBgYmAgYXJlIGJvdGggb2RkLiBTd2FwIHZhbHVlcyBzdWNoIHRoYXQgYGJgIGlzIHRoZSBsYXJnZXIgb2YgdGhlIHR3byB2YWx1ZXMsIGFuZCB0aGVuIHNldCBgYmAgdG8gdGhlIGRpZmZlcmVuY2UgKHdoaWNoIGlzIGV2ZW4pLi4uXG5cdFx0aWYgKCBhID4gYiApIHtcblx0XHRcdHQgPSBiO1xuXHRcdFx0YiA9IGE7XG5cdFx0XHRhID0gdDtcblx0XHR9XG5cdFx0YiA9IGIgLSBhOyAvLyBiPTAgaWZmIGI9YVxuXHR9XG5cdC8vIFJlc3RvcmUgY29tbW9uIGZhY3RvcnMgb2YgMi4uLlxuXHRyZXR1cm4gYSA8PCBrO1xufSAvLyBlbmQgRlVOQ1RJT04gYml0d2lzZSgpXG5cblxuLy8gR1JFQVRFU1QgQ09NTU9OIERJVklTT1IgLy9cblxuLyoqXG4qIEZVTkNUSU9OOiBjb21wdXRlKCBhcnJbLCBjbGJrXSApXG4qXHRDb21wdXRlcyB0aGUgZ3JlYXRlc3QgY29tbW9uIGRpdmlzb3IuXG4qXG4qIEBwYXJhbSB7TnVtYmVyW118TnVtYmVyfSBhcnIgLSBpbnB1dCBhcnJheSBvZiBpbnRlZ2Vyc1xuKiBAcGFyYW0ge0Z1bmN0aW9ufE51bWJlcn0gW2NsYmtdIC0gYWNjZXNzb3IgZnVuY3Rpb24gZm9yIGFjY2Vzc2luZyBhcnJheSB2YWx1ZXNcbiogQHJldHVybnMge051bWJlcnxOdWxsfSBncmVhdGVzdCBjb21tb24gZGl2aXNvciBvciBudWxsXG4qL1xuZnVuY3Rpb24gY29tcHV0ZSgpIHtcblx0dmFyIG5hcmdzID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRhcmdzLFxuXHRcdGNsYmssXG5cdFx0YXJyLFxuXHRcdGxlbixcblx0XHRhLCBiLFxuXHRcdGk7XG5cblx0Ly8gQ29weSB0aGUgaW5wdXQgYXJndW1lbnRzIHRvIGFuIGFycmF5Li4uXG5cdGFyZ3MgPSBuZXcgQXJyYXkoIG5hcmdzICk7XG5cdGZvciAoIGkgPSAwOyBpIDwgbmFyZ3M7IGkrKyApIHtcblx0XHRhcmdzWyBpIF0gPSBhcmd1bWVudHNbIGkgXTtcblx0fVxuXHQvLyBIYXZlIHdlIGJlZW4gcHJvdmlkZWQgd2l0aCBpbnRlZ2VyIGFyZ3VtZW50cz9cblx0aWYgKCBpc0ludGVnZXJBcnJheSggYXJncyApICkge1xuXHRcdGlmICggbmFyZ3MgPT09IDIgKSB7XG5cdFx0XHRhID0gYXJnc1sgMCBdO1xuXHRcdFx0YiA9IGFyZ3NbIDEgXTtcblx0XHRcdGlmICggYSA8IDAgKSB7XG5cdFx0XHRcdGEgPSAtYTtcblx0XHRcdH1cblx0XHRcdGlmICggYiA8IDAgKSB7XG5cdFx0XHRcdGIgPSAtYjtcblx0XHRcdH1cblx0XHRcdGlmICggYSA8PSBNQVhJTlQgJiYgYiA8PSBNQVhJTlQgKSB7XG5cdFx0XHRcdHJldHVybiBiaXR3aXNlKCBhLCBiICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gZ2NkKCBhLCBiICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGFyciA9IGFyZ3M7XG5cdH1cblx0Ly8gSWYgbm90IGludGVnZXJzLCBlbnN1cmUgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGFuIGFycmF5Li4uXG5cdGVsc2UgaWYgKCAhaXNBcnJheSggYXJnc1sgMCBdICkgKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2djZCgpOjppbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBNdXN0IHByb3ZpZGUgYW4gYXJyYXkgb2YgaW50ZWdlcnMuIFZhbHVlOiBgJyArIGFyZ3NbIDAgXSArICdgLicgKTtcblx0fVxuXHQvLyBIYXZlIHdlIGJlZW4gcHJvdmlkZWQgd2l0aCBtb3JlIHRoYW4gb25lIGFyZ3VtZW50PyBJZiBzbywgZW5zdXJlIHRoYXQgdGhlIGFjY2Vzc29yIGFyZ3VtZW50IGlzIGEgZnVuY3Rpb24uLi5cblx0ZWxzZSBpZiAoIG5hcmdzID4gMSApIHtcblx0XHRhcnIgPSBhcmdzWyAwIF07XG5cdFx0Y2xiayA9IGFyZ3NbIDEgXTtcblx0XHRpZiAoICFpc0Z1bmN0aW9uKCBjbGJrICkgKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnZ2NkKCk6OmludmFsaWQgaW5wdXQgYXJndW1lbnQuIEFjY2Vzc29yIG11c3QgYmUgYSBmdW5jdGlvbi4gVmFsdWU6IGAnICsgY2xiayArICdgLicgKTtcblx0XHR9XG5cdH1cblx0Ly8gV2UgaGF2ZSBiZWVuIHByb3ZpZGVkIGFuIGFycmF5Li4uXG5cdGVsc2Uge1xuXHRcdGFyciA9IGFyZ3NbIDAgXTtcblx0fVxuXHRsZW4gPSBhcnIubGVuZ3RoO1xuXG5cdC8vIENoZWNrIGlmIGEgc3VmZmljaWVudCBudW1iZXIgb2YgdmFsdWVzIGhhdmUgYmVlbiBwcm92aWRlZC4uLlxuXHRpZiAoIGxlbiA8IDIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0Ly8gSWYgYW4gYWNjZXNzb3IgaXMgcHJvdmlkZWQsIGV4dHJhY3QgdGhlIGFycmF5IHZhbHVlcy4uLlxuXHRpZiAoIGNsYmsgKSB7XG5cdFx0YSA9IG5ldyBBcnJheSggbGVuICk7XG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGFbIGkgXSA9IGNsYmsoIGFyclsgaSBdLCBpICk7XG5cdFx0fVxuXHRcdGFyciA9IGE7XG5cdH1cblx0Ly8gR2l2ZW4gYW4gaW5wdXQgYXJyYXksIGVuc3VyZSBhbGwgYXJyYXkgdmFsdWVzIGFyZSBpbnRlZ2Vycy4uLlxuXHRpZiAoIG5hcmdzIDwgMyApIHtcblx0XHRpZiAoICFpc0ludGVnZXJBcnJheSggYXJyICkgKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnZ2NkKCk6OmludmFsaWQgaW5wdXQgYXJndW1lbnQuIEFjY2Vzc2VkIGFycmF5IHZhbHVlcyBtdXN0IGJlIGludGVnZXJzLiBWYWx1ZTogYCcgKyBhcnIgKyAnYC4nICk7XG5cdFx0fVxuXHR9XG5cdC8vIENvbnZlcnQgYW55IG5lZ2F0aXZlIGludGVnZXJzIHRvIHBvc2l0aXZlIGludGVnZXJzLi4uXG5cdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0YSA9IGFyclsgaSBdO1xuXHRcdGlmICggYSA8IDAgKSB7XG5cdFx0XHRhcnJbIGkgXSA9IC1hO1xuXHRcdH1cblx0fVxuXHQvLyBFeHBsb2l0IHRoZSBmYWN0IHRoYXQgdGhlIGdjZCBpcyBhbiBhc3NvY2lhdGl2ZSBmdW5jdGlvbi4uLlxuXHRhID0gYXJyWyAwIF07XG5cdGZvciAoIGkgPSAxOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0YiA9IGFyclsgaSBdO1xuXHRcdGlmICggYiA8PSBNQVhJTlQgJiYgYSA8PSBNQVhJTlQgKSB7XG5cdFx0XHRhID0gYml0d2lzZSggYSwgYiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhID0gZ2NkKCBhLCBiICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhO1xufSAvLyBlbmQgRlVOQ1RJT04gY29tcHV0ZSgpXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXB1dGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/compute-gcd/lib/index.js\n");

/***/ })

};
;