# Generated by Django 5.0.11 on 2025-02-13 23:35
from typing import Dict
from django.db.models import Count
from django.db import migrations
from collections import defaultdict

"""
One-time forward-only migration to be applied to prod data.
Purpose: First, check that contacts records are duplicated in full. Then,remove duplicate contacts.  Where operation.point_of_contact was one of the duplicates, replace with the unique contact.
"""


def count_stats(Contact) -> Dict[str, int]:
    """Collects and returns key statistics about the data before and after migration."""
    return {
        'total_contacts': Contact.objects.count(),
        'total_unique_contacts': Contact.objects.values(
            'first_name', 'last_name', 'email', 'position_title', 'phone_number', 'business_role', 'operator', 'address'
        )
        .distinct()
        .count(),
        'total_unique_emails': Contact.objects.values('email').distinct().count(),
        'total_duplicated_contacts': Contact.objects.values('email')
        .annotate(count=Count('id'))
        .filter(count__gt=1)
        .count(),
    }


def migrate_remove_duplicate_contacts(apps, schema_monitor):

    Contact = apps.get_model('registration', 'Contact')
    Operation = apps.get_model('registration', 'Operation')

    before_stats = count_stats(Contact)
    if before_stats['total_unique_contacts'] != before_stats['total_unique_emails']:
        raise Exception('There are partially duplicated contacts that must be addressed before running this migration.')

    email_groups = defaultdict(list)
    # group contacts by email
    for contact in Contact.objects.all():
        email = contact.email
        if Contact.objects.filter(email=email).count() > 1:
            email_groups[email].append(contact)

    for email, contacts in email_groups.items():
        primary_contact = contacts[0]
        duplicate_contacts = contacts[1:]

        # assign points of contact
        Operation.objects.filter(point_of_contact__in=duplicate_contacts).update(point_of_contact=primary_contact)

        # delete duplicate contacts
        Contact.objects.filter(id__in=[contact.id for contact in duplicate_contacts]).delete()

    after_stats = count_stats(Contact)

    # contact assertions
    assert after_stats['total_duplicated_contacts'] == 0
    assert before_stats['total_unique_contacts'] == after_stats['total_unique_contacts']
    assert after_stats['total_contacts'] == after_stats['total_unique_contacts']

    # make sure operations have a valid point of contact
    for operation in Operation.objects.all():
        # incomplete operations may not have a point of contact
        if operation.bc_obps_regulated_operation:
            assert operation.point_of_contact is not None
            assert operation.point_of_contact.id in Contact.objects.values_list('id', flat=True)


class Migration(migrations.Migration):

    dependencies = [
        ('registration', '0079_update_contact_business_roles'),
    ]

    operations = [
        migrations.RunPython(migrate_remove_duplicate_contacts, migrations.RunPython.noop, elidable=True),
    ]
